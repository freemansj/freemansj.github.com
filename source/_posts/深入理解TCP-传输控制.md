---
title: 深入理解TCP-传输控制
tags:
  - TCP/IP
  - 深入理解TCP系列
categories:
  - 计算机网络
date: 2017-11-07 13:43:40
---

>{% blockquote [Zhu Xi] %}
	为有源头活水来...
 {% endblockquote %}

> 2017-11-19 2rd


## BEGIN

------

## 可靠传输基础

 序列号( SYN )与确认应答号( ACK ): 
 
	1. 发送端发送某一 TCP 段, 需要清楚接收端是否成功接收这个 TCP段 ,  才能确定下一步是重新发送还是继续发送下一 TCP段.
	2. 接收端也需要清楚自己接收的是哪个 TCP段 , 才能决定下一步的工作(重复出错丢弃, 按需请求重发).
	3. TCP段 乱序到达, 需要知道如何正确排序.
 
<!--more-->

 序列号与确认应答提供了一个不错的实现.
 
 详细见 [深入理解TCP-连接建立与断开](https://www.cpphonor.cn/2017/10/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP-%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E4%B8%8E%E6%96%AD%E5%BC%80/#more)


## 重发与窗口机制


### 为何需要重发:

 #### 未成功接收(传输中丢失或因拥堵超时)
 
 TCP数据段包裹在一个IP包中传输( you drop I drop ). IP包可能在网络中丢失, 比如:
 经过太多的路由器达到 hop limit or 路由器太过拥挤导致一些IP包被丢弃 or routing table没有及时更新...
 
 
 #### 接收数据包出错
 
 接收端可以通过校验 TCP 数据段头部中 checksum 区域来检验 TCP 数据段是否出错.
 TCP 数据段的 checksum 算法与 IP 包的 checksum 类似.不同的是:
 > IP协议的 checksum 只校验头部,TCP数据段头部的 checksum 会校验包括 IP 头部、TCP 头部和 TCP 数据在内的整个序 列,确保 IP 地址、端口号和其他相关信息正确.
 如果 TCP 数据段出错, 接收方可以简单的丢弃該 TCP 数据段，也就相当于 TCP 数据段丢失.
 关于如何计算校验和,这里不进行深入研究...


------


### 窗口机制

首先需要知道的是, TCP是以段为单位发送数据的, 段的长度称为最大消息长度MSS
TCP 传输大量数据时以 MSS 的大小将数据进行分割,重发时也以MSS为单位
 MSS 在TCP连接建立的过程中(三次握手)由两端主机进行协商(告诉对方自己的接口能适应的MSS的大小),取较小值

#### 何为窗口控制?
	使用大量 Buffer, 实现同时对多个段进行确认应答的功能,发送端主机未接收到确认应答也可以先发送下一个段.
	但是,在收到 ACK 前, 必须保证对应的段仍保存一份在缓存区, 以供重发.
	一旦收到 ACK ,相应的段就可以从缓存区中清除

#### 为何要有窗口控制? 

	1.TCP 每发送一个段都得进行一次确认应答处理,则当 RTT 较长时,通信性能会很低效.
	2.考虑 TCP段 的确认应答未返回的情况:
	一种可能是 数据未能到达, 还有一种是接收端返回 ACK 然而途中丢失了...
	这种情况下, 若是没有窗口控制, 则这些未接收返回的 ACK 的数据包都会被重发.
	而有了窗口控制之后, 我们会发现, 即使中间丢失了一些确认应答也无妨:
	考虑到 若是 ACK:1001 ~ ACK:3001 均丢失了, 但我们接收到了ACK:4001, 那也间接表明了4001以前的数据段都已经成功接收.


#### 发送窗口

发送窗口大小由接收端（流量控制）和底层网络的拥塞程度（拥塞控制）决定

{% qnimg 20171108TCPsenderwindow.png 'class:tcp-pic' extend:?imageView2/0/w/800/q/100|imageslim %}

------

#### 接收窗口

TCP 允许接收进程以自己的速率拉数据.接收端的 部分被分配缓冲区 可以被已接收且确认,正在等待被接收进程"拉"的字节占据.
接收窗口大小总是小于或等于缓冲区大小, 它的大小决定了接收窗口在被淹没（流量控制）之前可以 从发送端接收的字节数.

{% qnimg 20171108TCPrecvwindow.png 'class:tcp-pic' extend:?imageView2/0/w/800/q/100|imageslim %}

------

#### 滑动窗口

　　收到序列号合法的确认应答的情况下,便可以将窗口滑动到确认应答中的序列号的位置,以顺序地将多个段同时发送提高通信性能.收到的确认应答号在范围之外或者校验出错时丢弃此ACK, 计时继续.

{% qnimg TCPslidewindow.png 'class:tcp-pic' extend:?imageView2/0/w/800/q/100|imageslim %}

------

### 超时重发

	当发送端送出某一 TCP 数据段后, 将开启一个计时器, 等待接收端的 ACK 回复.
	如果接收端正确接收到符合次序的数据段,则返回带 ACK 标志的包.
	发送端收到 ACK 回复后，继续移动窗口,发送接下来的数据段. 
	如果直到计时完成, 发送端还是没有收到 ACK 回复，那么发送端推断之前发送的数据段已经丢失, 重新发送之前的数据段。
	这个计时等待的时间叫做重发超时(RTO, retransmission timeout).
	一般 初始值设置在6秒左右,在 Unix 和 Windows 中,超时都以 0.5s 为单位进行控制,即重发超时为 0.5s 的整数倍.
	重发后的等待时间会以指数函数增长，但不会无限增长，超过一定次数仍无应答则会强制关闭连接并通知应用程序通信异常终止.

那么,如何确定RTO呢?
　　TCP要求不论处在何种网络环境下都要提供高性能的通信,并且无论网络拥堵情况如何变化, 都必须保持这一特性.
为此, 它每次发包都会计算往返时间RTT【称采样RTT(sampling-rtt)】 及其 偏差(RTT抖动,标准差std),RTO的值就比这两者的总和高一点.
具体如何计算在不同的平台可能会有不同, 我知道的一种是: sum(srtt[i~i+n])/n + 4 * std


> 为何要还需考虑偏差? 
> --> 根据网络环境的不同，往返时间可能会发生大幅度的波动, 因为各个数据包的分段可能是经过不同线路到达的.
> 这种情况下,如果我们设置了过小的RTO,那么发送端等待很短的时间就重新发送,而实际上之前发送的片段并没有丢失，只是传输速度比较慢而已. 这样重复发送数据段, 从而浪费网络传输资源.
> 　　换个角度,如果RTO时间设置的过长,那么当数据段已经丢失的情况下,发送端不能及时重发, 则会造成网络资源的闲置.
> 因此, 将偏差值也考虑在内可以尽量避免浪费网络流量,保持TCP特性.

------

### 高速重发

　　在发送端主机连续三次接收到同一个确认应答时,才会对其所对应的数据进行重发
　　在窗口较大时, 若1001~2000的 TCP段 还未到达接收端或已丢失,接收端将发送ACK:1001
　　由窗口控制机制, 发送端仍会继续发送2001~n的 TCP段, 接收端仍将继续发送ACK:1001,但同时将缓存2001~n的 TCP段.
　　高速重发机制在连续3次接收到ACK:1001后才认定需要重发1001~2000的数据段,这比超时重发会高效不少.

{% qnimg 20171108TCPgaosuchongfa.png 'class:tcp-pic' extend:?imageView2/0/w/800/q/100|imageslim %}

------

## 流机制

### 流量控制

#### 流量控制反馈

TCP 中数据流和流量控制反馈:

{% qnimg 20171108TCPflowcontrol.png 'class:tcp-pic' extend:?imageView2/0/w/800/q/100|imageslim %}

接收端 TCP 反馈控制发送端 TCP, 发送方 TCP 反馈控制 发送端进程.

接收端主机指示发送端主机对发送数据的量进行控制.

{% qnimg 20171108TCP2.png 'class:tcp-pic' extend:?imageView2/0/w/800/q/100|imageslim %}

#### 为何需要流控制?

	发送端若是能发多少、想发多少就发多少, 接收端处理不过来(比如它可能因为收到的是一个毫无关系的数据包而在处理某些问题上花费一些时间)
	那它可能会在高负荷情况下无法接收任何数据。
	如此一来，如果接收端将本应该接收的数据丢弃的话，就又会触发重发机制，从而导致网络流量的浪费。


	流控制机制为接收端提供了一个选择的权利:
	　它可以通过TCP首部中的一个 Window Size 字段通知发送端自己空余的缓冲区大小(这个值越大，说明网络的吞吐量越高,称为窗口大小).
	发送端便不会发送超过这一大小限制的数据,且当接收端这个缓冲区面临数据溢出时,窗口大小的值会随之被设置为一个更小的值通知给发送端,从而控制数据发送量.


	1. 发送窗口的打开、关闭(见「发送窗口」)和收缩由接收端控制.
	当一个 新ackNo 允许发送窗口关闭时, 发送窗口关闭( |~=> ... ~| ). 
	当接收方通知的 新rwnd 允许发送方窗口打开时(new ackNo + new rwnd > last ackNo + last rwnd)，发送窗口打开( |~ ... ~|=> ).


	2. 若是[ new ackNo + new rwnd > last ackNo + last rwnd ] 例(102 + 4 < 100 + 10) 则会发生窗口的收缩( 100|~->102 ... 106<-~|110 )
	此时, 它产生了一个问题: 
	已经被发送的100~110 字节中, 100~102成功清除缓存区 而 106~110则处于窗口之外
	(可能只是106~110延迟未到达,然接收端却不清楚这部分是否发送),
	后面发送端还得重复发这部分数据.
	我们希望能尽量避免这种情况的发生, 一种方法是 :
	让接收端推迟反馈, 直到在它的窗口中有足够的缓冲区空间(接收端应用程序'拉') 或者 之前数据确认到达已返回一个受期待的ack 如 106. 
	总之就是尽量使发送窗口不会发生 右界左移(收缩)


	3. 某些情况下(如缓冲区已满), 接收端在一段时间内不想接收来自发送端的数据,
	此时接收端会发送rwnd为0的段, 若按照上方的方法分析, 则此时无法避免地会发生窗口收缩.
	然鹅~ 实际上, 发送端并不真的收缩窗口大小, 它会停止发送数据直到新的窗口通告到达.
	即使当窗口因为来自接收方的命令而暂时关闭了, 发送端也总可以发送一个 1 字节数据的数据段, 称为[窗口探测], 用来防止[死锁]-(见↓).

> 若无窗口探测,为何或何时会死锁？
> 接收端发送 rwnd=0 以使发送端停下来等待新的窗口通告, 过一段时间后, 接收端想要解除对发送端的"封印", 会发送新的rwnd通告给发送端, 然而, 这个通告若是在传输过程中丢失了... 没错, 此时发送端未接收到新通告故继续等待接收端的指示, 而接收端可不知道这些, 它以为发送端收到了指示, 与上也在等待发送端发送数据! 此时 死锁便产生了.

------

## 网络过载与拥塞窗口

### 拥塞

网络中的链路容量和交换结点中的缓存和处理机都有着工作的极限, 当网络的需求超过它们的工作极限时, 就出现了拥塞. 

拥塞控制就是防止过多的数据注入到网络中, 这样可以使网络中的路由器或链路不致过载.

### 慢启动:

在拥塞发生时循序减少主机发送到网络中的 TCP段 数,使得发生拥塞的路由器有足够的时间把队列中积压的 TCP段 处理完毕

{% qnimg 20171108TCP3.png 'class:tcp-pic' extend:?imageView2/0/w/800/q/100|imageslim %}

发送端维持一个 "拥塞窗口"的窗口大小的值，该值与接收端口共同决定了发送端的发送窗口.
当主机发送数据时,在"拥塞窗口"值和接收端通知的窗口大小 间选择一个较小值发送.
每收到一个确认应答就增发一个段(发送段数指数增长,这样的激增可能导致网络拥塞,故引入了慢启动阀值)
最后会达到一个提前预设的 "慢启动阀值(slow-start threshold)",此时:

	cwnd < ssthresh， 继续使用慢启动算法;
	cwnd > ssthresh，停止使用慢启动算法，改用拥塞避免算法;
	cwnd = ssthresh，既可以使用慢开始算法, 也可以使用拥塞避免算法.
	[cwnd为窗口大小,初始为1]

所谓拥塞避免算法就是:每经过一个往返时间 RTT 就把发送方的拥塞窗口+1,即让拥塞窗口缓慢地增大,按照线性规律增长.
当出现网络拥塞,比如丢包时,将慢启动阀值重设为原先的值,然后将cwnd设为1, 执行慢启动算法(较低的起点,指数级增长)


### 快重传+快恢复:

减少因为拥塞导致的数据包丢失带来的重传时间, 从而避免传递无用的数据到网络

{% qnimg 20171108TCP4.jpg 'class:tcp-pic' extend:?imageView2/0/w/800/q/100|imageslim %}

接收方建立这样的机制, 如果一个包丢失, 则对后续的包继续发送针对该包的重传请求;
一旦发送方接收到 3 个一样的确认, 就知道该包之后出现了错误(网络轻微阻塞), 立刻重传该包:
此时发送方开始执行 "快恢复" 算法:

	慢启动阀值减半;
	cwnd设为慢启动阀值减半后的数值;
	执行拥塞避免算法(高起点,线性增长).


> 新版本的TCP中, 如果 发生超时, TCP进入慢启动状态(如果它已经处于此状态,则开始新的一轮); 如果三
次重复 ACK 到达, 则 TCP 进入快速恢复状态, 并且 有更多的重复 ACK 到达, 它仍保持这种状态.


------



## 提高网络利用率

### Nagle算法

　Nagle算法即 在发送端还有需要发送的数据 然而数据量较小的情况下 延迟发送,等待较合适的数据量 (发送端糊涂窗口综合症, 可能使得发送端应用程序刚推送几个字节的数据 TCP就创建段以发送这些数据,网络利用率低下).
若以下两条件都不满足，则执行 Nagle 算法(有开启的话):
* 已发送的数据都已经收到 ACK
* 可以发送达到 MSS 的数据时

Nagle 算法能提高网络的利用率但可能会造成某种程度的延迟,故某些系统(如窗口系统)中可能会关闭对他的支持.

### Clark算法与延迟确认

　为解决 消耗数据速率 远低于 数据到达速率 而产生的接收端糊涂窗口综合征(接收端应用程序龟速'拉数据',缓冲区每次都趋满状态,返回一个很小的窗口), Clark 提出, 数据一到达就发送确认(与延迟应答的区别), 但是声明一个大小为 0 的窗口, 直到有足够的空间容纳大段，或者至少半个接收缓冲区是空的才正常反馈 rwnd值.

＝另一种方法为延迟发送确认 , 见下一部分 ↓


### 延迟应答

　延迟应答即在收到数据之后不立即返回 ACK ,而是延迟一段时间再返回：
* 在未收到两倍最大段长的数据（不同操作系统可能不同）前不返回ACK
* 其他情况,最大延迟0.5s返回 ACK 
* 延迟的时间也不宜过长,不然可能导致发送端重发


### 捎带应答

　捎带应答即在同一个 TCP包中即发送数据又发送 ACK ,以使得收发的数据量减少的一种机制.

* 到 TCP层 将接收的数据 送至应用层处理后生成返回数据后 再进行发送请求 为止,必须等待 ACK 的发送
* 若接收数据后立即返回 ACK ,就无法实现捎带应答
* 即 延迟应答是实现捎带应答的基础.


------

## END