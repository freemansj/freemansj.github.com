---
title: "You Don't Know JS 上卷(Ⅰ) 归纳"
tags:
  - JavaScript
categories:
  - 深入理解JavaScript
  - YouDon'tKnowJS
date: 2018-03-08 20:13:34
---

>{% blockquote [No name] %}
	想的太多, 做的太少, 只会使你迷茫...

{% endblockquote %}

<!--more-->

---

## 一.JavaScript的编译执行
---


### 1.1.演员 : 引擎，编译器，作用域

    - 1.编译器对代码进行分词（或词法化）并解析（抽象语法树），并将其中的变量名注册到作用域（在当前作用域中还未存在的）
    - 2.编译器通过AST生成可执行代码
    - 3.引擎对变量（标识符，包括函数）进行LHS（待赋值空间）和RHS（查变量源值）查询【在作用域中】（此阶段为引擎对代码的编译阶段）
    - 4.当引擎在当前作用域中查询不到想要的东西时，他会去查询上一级作用域，直至全局。（作用域嵌套情况，由此也可知内层会覆盖外层作用域变量）
      - 1.对于RHS查询，若在所有的作用域中都找不到变量，则抛出ReferenceError(引用异常);
      - 2.对于LHS查询，找不到则会创建一个并返回给引擎，前提是在“非严格模式”下,否则同RHS.
      - 3.是故区别RHS和LHS很重要。
    - 5.若查询成功，接下来，若是对变量操作非法，如对非函数类型进行函数调用，则会抛出TypeError.

### 1.2.作用域模型

    - 1.JavaScript使用词法作用域，另一种模型是动态作用域模型（Bash,Perl）;
    - 2.词法作用域一般根据词法关系保持书写时的自然关系不变;
    - 3.一个作用域不能包含于两个外作用域;  
    - 4.欺骗词法:修改作用域[eval]或创建新作用域[with]  
      - 1.eval(..)接受一个字符串str为参数，将str视作原本就存在于该位置【eval()所在】的代码（类似于inline）
           //通过eval，可能隐蔽地在内部声明一个与外层作用域同名的变量，从而覆該变量。
           //类似的有new Function(..)
      - 2.with:
      ```js
           //例：
           var obj={a:1,b:2,c:3}; with(obj){a=2;b=3;c=4;} 
           /*即通过with可优雅地重复地引用同一对象obj的多个属性。
            * with可将一个对象处理为完全隔离的词法作用域（即凭空创建了一个新的词法作用域：with函数作用域）
            * 当with块中的变量赋值时，若作用域链中找不到該变量，则可能将其添加到全局作用域(非严格模式下)，从而污染全局空间*/
      ```
    - 5.欺骗词法会带来不确定性，从而，引擎编译时难以优化甚而不优化，会严重降低执行效率，应尽量少用。
    - 6.可将作用域模型比作一座大楼，第一层就是当前作用域，顶层就是全局作用域
      - 1.每一层中的标识符优先级都是同等的。

补:【词法作用域关注函数在何处声明，而动态作用域关注的时函数从何处调用(this机制亦是如此)】



---



## 二.函数作用域与块作用域

---


### 2.1.函数作用域

    - 1.每个函数块都会创建一个该层的作用域，该层包含此函数中所有的标识符（当然，不包括内层函数中的标识符）
      1.内层函数可以访问外层函数，因为外层函数的作用域在它的“楼上”.
      2.也因此，需要保护外层的变量，它们可能被内层破坏性地进行非法操作。
    - 2.通过一个函数包裹，隐藏内部实现（变量与函数），或者内层声明与外层同名的标识符，覆盖外层
      - 1.将所有仅期望被当前一个或几个函数访问的变量，同这几个函数一起用一个外层函数包裹起来，保护它们不被全局中另外的内层函数破坏性操作。
      - 2.符合最小暴露原则
      - 3.可规避冲突
            1.当加载了多个第三方库的时候，库会在全局作用域中声明一个独特的变量(通常是一个对象)，用作库的命名空间。
            2.所有需要暴露给外界的功能都会成为这个对象的属性(可通过obj.attr访问)
            3.这样該库的命名空间就不会被污染，内部的变量函数也不会被其他的库或者内层函数非法操作，也不会与其他库命名冲突。
            4.就如同在全局作用域与库之间加了一个夹层，以供保护。
      - 4.类似的有模块管理，可保持私有，无冲突的作用域（通过依赖管理器的机制）
    - 3.闭包（function foo(参数){}）(外部参数);
      - 1.区分函数声明与函数表达式: 在整个声明中，function为第一个词，则为函数声明，否则为函数表达式.
      - 2.闭包的第一个()使其被解释为一个函数表达式.
      - 3.第二个()使該函数表达式立即执行，可传入外部参数
         ```js
            //1.若不传入参数，亦可以写成（function foo(){} () ）;
            //2.可将外部的对象当作参数传入，将其改成一个较为合理的标识符
            //如：
             	(function foo(global){...})(window)
            //3.妙用：(function foo(undefined){})();不传入参数，因此，形参undefined就真的成了undefined
          ```
    - 4.匿名与具名，行内表达式
      - 1.函数表达式可以匿名，但函数声明不行（另一个区分声明与表达式的方法）
      - 2.匿名函数书写和使用简单便捷，在库和工具中应用广泛，用作回调函数亦是非常常见。
      - 3.缺点
            1.匿名函数不易调试，因为没有有意义的函数名
            2.在递归中，引用自身使需要使用已过期的arguments.callee引用
            3.可读性不高
      - 4.行内表达式，它具备匿名函数的所有优点
            1.行内表达式，匿名与具名没有影响
            2.行内表达式应该具名，以规避匿名函数的缺点。

### 2.2.块作用域

    - 1.with语句块，with从对象创建出的作用域仅在with声明有效
    - 2.try/catch中的catch分句亦会创建一个块作用域，一个catch创建一个，其中的标识不会泄露到外层。
    - 3.let关键字：
      - 1.let可将变量绑定到所在的任意作用域（块）中，通常在{...}内部
      - 2.可通过{..}为let创建一个 用于绑定的块
      - 3.需要时刻注意哪些块作用域中有绑定的变量，尽量避免将这些块移动或包含在其他的块中，否则可能导致代码混乱。
      - 4.解决(3.)中的问题，通过(2.)的方法，即为块作用域显示地创建块
        ```js
          //例：
          var foo=true; 
          if(foo){ 
              { let bar=foo*2; console.log(bar); }/*【显式的块】*/ 
          }
          //此时，整个显式的块都可以方便地移动而不会对外部的if声明的位置和语义造成影响。
        ```
      - 5.let声明不会对变量进行提升，即“变量声明处”之后才可以使用
      - 6.let其他作用：垃圾回收，let循环
    - 4.const:创建值固定的块作用域变量


### 2.3.提升

    - 1.在每个作用域中，函数和变量的声明会被提升，赋值（包括函数表达式的赋值）等操作则被留在原地等待执行。
    - 2.函数提升的优先级高于变量。(两者同名的情况)
    - 3.提升发生在编译阶段
      - 例：var a=2; 被编译为 var a;  a=2; 一个发生在编译阶段，一个在执行阶段


---



## 三.闭包
---


### 3.1.何为闭包

当函数（内层函数）能记住并访问所在的词法作用域时，就产生了闭包.

    - 1.内层函数Inner能访问外层函数Outer的词法作用域，将該Inner传递到外部(词法作用域之外)，它就持有对原作用域的引用，这个引用就是闭包。
    - 2.无论使用何种传递方式将Inner传递到外部为B-Inner，当在外部执行B-Inner时，就使用了闭包。
    - 3.B-Inner保存了Inner的原作用域的引用，因此Outer的中的“资源”不会被垃圾回收，可供B-Inner使用，直到B-Inner释放。

### 3.2.闭包的使用

在定时器、事件监听、Ajax请求、跨窗口通信、Web Worker或者其他的异步（或同步）任务中，只要使用了回调函数，实际上就在使用闭包。

### 3.3.立即执行函数表达式(IIFE)

IIFE确实创建了闭包，也是最常用来创建被封闭起来的闭包的工具

    - 1.然而它本身并不使用闭包的方式查询得到相应的词法作用域中的变量，反而常常使用普通的词法作用域查找就能找到需要的变量。
    - 2.循环中的IIFE,若要保存for循环的值i,者需要将其引入到IIFE创建的作用域中，否则作用域仍然为空：
    ```js
         //例：
         for(var i=1;i<=5;i++){ 
             (function(){
                 setTimeout（function timer(){console.log(i)},1000*i）
             })(); 
         }
         //IIFE只会是一个空作用域，需要将i作为参数传入，或者在IIFE内定义一个变量接受i的值。
         //【每次迭代都会创建一个新的作用域】
    ```

### 3.4.let在闭包应用上的作用

    - 1.let绑定了一个块作用域,即{..}，該作用域是可封闭的，可作为闭包的块作用域，let j=i;则此时就保留了每次循环的i值
    - 2.for(let i=1;.....){...} for循环头部的let声明会有一个特殊的行为
      - 1.该行为支出变量在循环过程中不止被声明一次，而是每次迭代都会声明
      - 2.随后的每个迭代都会使用上一轮迭代结束时的值来初始化这个变量
      - 3.这亦能起到闭包作用

    - 3.即 let帮闭包绑定了一个块作用域以供使用

### 3.5.模块, 闭包的一个强大应用

    - 1.必须要有外部的封闭函数如CoolModule()，该函数必须至少被调用一次(每次调用都会创建一个新的模块实例)
    - 2.封闭函数必须返回至少一个内部函数（公共API），这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态
      - 1.可通过字典方式如 return {key:funName,...}; 
      - 2.或先保留公共API对象的内部引用，在返回該引用：var publicAPI={key:funName,...}; return publicAPI;

    - 3.通过var foo=CoolModule(); foo.apifunc1(); foo.apifunc2();
    - 4.当然也可以定义可接受参数的模块，模块也是普通的函数。
    - 5.ES6中开始使用import导入（从别的模块导入当前），export导出（从当前模块导出） API成员
      - ES6中模块没有“行内”格式，只能一个文件定义一个模块


---

TO BE CONTINUE ...
---
　　沉迷 JavaScript 不能自拔,日渐消瘦...
