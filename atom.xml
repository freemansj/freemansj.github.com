<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>扶摇直上</title>
  
  <subtitle>Indulge ...</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.cpphonor.cn/"/>
  <updated>2018-10-16T13:53:45.634Z</updated>
  <id>http://www.cpphonor.cn/</id>
  
  <author>
    <name>Hugh Freeman</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Detail-1-Algorithm-Complexity</title>
    <link href="http://www.cpphonor.cn/2018/09/20/Details-1-Algorithm-Complexity/"/>
    <id>http://www.cpphonor.cn/2018/09/20/Details-1-Algorithm-Complexity/</id>
    <published>2018-09-20T13:03:42.000Z</published>
    <updated>2018-10-16T13:53:45.634Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <hr=""><h3 id="算法-复杂度分析"><a href="#算法-复杂度分析" class="headerlink" title="算法 复杂度分析"></a>算法 复杂度分析</h3><blockquote><p>常量时间，一行代码执行一次的时间，这独立于底层机器，是<code>理论上</code>的、<code>用于分析</code>的 一个执行时间。</p></blockquote><blockquote><p>Big O(fn) 表示法，展示的是，一个算法 它的<u>执行效率 随着 数据规模的增大</u>的<code>变化趋势</code>（常量时间项、低阶项、常数系数等对整体变化趋势的影响可以忽略=&gt;注意此处说的是整体变化趋势,如 原先是线性级，加上常量级、乘上一个常系数，还是线性级）。</p></blockquote><p><a href="https://upload-images.jianshu.io/upload_images/4593922-3b991d95c636319b.png?imageMogr2/auto-orient/" title="算法复杂度(图片来源于网络)" class="gallery-item" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/4593922-3b991d95c636319b.png?imageMogr2/auto-orient/" alt="算法复杂度(图片来源于网络)"></a></p><p>1.常量复杂度O(1), 无论有几千几万行代码，一行代码执行几千几万次，只要它与 n 无关，那么，便还是常量时间复杂度O(1), 因为，它的执行效率，随着数据规模的增长，都是一样的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;i&lt;<span class="number">10000</span>;i++)&#123;</span><br><span class="line">        print i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1+ 10000*1  = T  (忽略了i的改变和条件判断式，save yourself)</span></span><br></pre></td></tr></table></figure></p><a href="http://ovge5llkw.bkt.clouddn.com/images/images/detail-1-BigO-present-O(1).png?imageView2/0/w/800/q/100|imageslim" title="O(1)" class="gallery-item" target="_blank" rel="noopener"><img alt="O(1)" src="http://ovge5llkw.bkt.clouddn.com/images/images/detail-1-BigO-present-O(1).png?imageView2/0/w/800/q/100|imageslim"></a><p>2.线性时间复杂度：O(n), 代码执行效率 与 数据规模 成正比：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;i&lt;n;i++)&#123;</span><br><span class="line">        print i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a href="http://ovge5llkw.bkt.clouddn.com/images/images/detail-1-BigO-present-O(n).png?imageView2/0/w/800/q/100|imageslim" title="O(n)" class="gallery-item" target="_blank" rel="noopener"><img alt="O(n)" src="http://ovge5llkw.bkt.clouddn.com/images/images/detail-1-BigO-present-O(n).png?imageView2/0/w/800/q/100|imageslim"></a><p>3.对数阶复杂度：O(logn): 包含了所有的 代码执行效率与数据规模成 对数形式增长的情况，如 log2 N、log3 N 、ln N等。至于为何可以将所有对数情况表示为 O(logn)?</p><ul><li><code>log3 N  = log3 2 * log2 N</code> ， 其中，log3 2是一个常量，故 <code>O(log3 N) = O(log2 N)</code></li></ul><a href="http://ovge5llkw.bkt.clouddn.com/images/images/detail-1-BigO-present-O(logn).png?imageView2/0/w/800/q/100|imageslim" title="O(logn)" class="gallery-item" target="_blank" rel="noopener"><img alt="O(logn)" src="http://ovge5llkw.bkt.clouddn.com/images/images/detail-1-BigO-present-O(logn).png?imageView2/0/w/800/q/100|imageslim"></a><p>4.其他的，如O(n^k) 、 O(nlogn) 等，可表示为 以上复杂度情况的嵌套，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;i&lt;n;i++)&#123; <span class="comment">// O(n)</span></span><br><span class="line">        <span class="keyword">for</span>(;j&lt;n;j++)&#123;</span><br><span class="line">            j = j*k;  <span class="comment">//k 为常数 （O(log_k N)中的底数）</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//复杂度 O(N) * O(log_k N)  =  O(N logN) 【由乘法规则】</span></span><br></pre></td></tr></table></figure><blockquote><p>图.jpg (不想画了)</p></blockquote><p>至于 O(2^n)、 O(N!)，它们被称为 非确定多项式量级时间复杂度，随着数据规模的增大，执行时间将会骤增！一般也很少会用到，用到了只能证明你这算法很可能有大问题、有很大的优化空间，不做分析。</p><p>简单总结一些分析算法时间复杂度的规则：<br>1）单段  代码看高频代码段：如循环。（<code>执行次数最多的代码</code>）<br>2）多段代码取最大阶项：如一段代码中有单循环和多重循环，那么取多重循环的复杂度（最大阶 <code>O(n^2) + O(n) =&gt; O(n^2)</code>）。<br>3）嵌套代码 用乘法规则：如递归、多重循环等 （<code>O(n)* O(m) = O(nm)</code>）<br>4）多个规模 用加法规则：如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相加（<code>O(m+n)</code>）。</p><hr><p>空间复杂度， 分析和时间复杂度差不多，只是，变成了 描述 <u>使用的空间 随着 数据规模的增长</u>u&gt;的 <code>变化趋势</code>。常量空间复杂度，表示 ，你使用的空间 不随着数据规模的变化而变化，此时你可能使用了 长度10000的数组….. </p><p>（此处略去 使用1000个常量空间的文字）</p><hr><h3 id="3-1-类-时间复杂度"><a href="#3-1-类-时间复杂度" class="headerlink" title="3(+1)类 时间复杂度"></a>3(+1)类 时间复杂度</h3><p>通常情况下，代码的执行次数还和各种控制条件有关，如在一个长度N的数组中查找一个元素，找到后便会直接退出，即并非每次都会执行N次的查询操作，亦即，上边的分析方法还不能满足我们的需求，因此，我们引入了多个类型的时间复杂度对代码执行效率进行理论分析：</p><hr><p>常见的时间复杂度类型有3种：<code>最好、最坏、平均 时间复杂度</code> ：</p><p>如 使用遍历方法，在一个 长度为 N的数组中查找一个元素Item（假设Item存在于数组中），Item的可能在第一位，此时是最理想情况，复杂度为O(1),即 最好平均复杂度。反之，元素在末尾 ，则为最坏时间复杂度，O(N)。而平均时间复杂度，则需要分析Item在各个位置上出现的概率和对应消耗，求取加权平均值：</p><ul><li>Item出现在第k位的概率为 1/n， 它消耗 k 个常量时间 :   k / n</li><li>加权平均值： <code>(∑k/n)/n</code> (其中 0 &lt; k≤ N) </li><li>=&gt; <code>n* (n+1)/2n =(1/2)  n + 1/2 =&gt; O(n)</code></li></ul><hr><p>还有一种 特定场景下的较为少见的时间复杂度：均摊时间复杂度(也有人称它”特殊情况下的平均时间复杂度”)</p><ul><li>可用场景：<ul><li>对一个数据结构进行一组连续操作，大部分时间下 时间复杂度都较低，个别情况下 时间复杂度较高，且这样情况的出现有一定规律。这种场景下，可以分析，是否能够<u>将 较高复杂度的操作的耗时 平摊到 其他时间复杂度较低的操作中</u> [称 <code>摊还分析</code>]。 此时分析出来的时间复杂度，称为 <code>&quot;均摊时间复杂度&quot;</code>.</li></ul></li><li>e.g.: <ul><li>有一个缓冲区，在它未满的时候，将新的元素直接压入缓冲区（假设需要一次操作O(1)），满的时候，一起送给缓冲区的消费者（假设需要n次操作 O(n) ）【需要将元素拷贝到另一个地方】+ 清空缓冲区（O(1)）【清空元素，实际上直接将当前指针指向缓冲区第一个位置即可】</li><li>这种场景下，可以将 满状态时的 n+1次的操作，平均分摊到 之前的n次 O(1)操作中， 即 相当于每个新元素加入都耗费 2O(1) ， 其 均摊时间复杂度为 ： O(1)</li></ul></li></ul></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot;&gt;&lt;div class=&quot;.article-g
      
    
    </summary>
    
      <category term="The-Details-CH.Algorithm" scheme="http://www.cpphonor.cn/categories/The-Details-CH-Algorithm/"/>
    
    
      <category term="基础篇" scheme="http://www.cpphonor.cn/tags/%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    
      <category term="Detail系列" scheme="http://www.cpphonor.cn/tags/Detail%E7%B3%BB%E5%88%97/"/>
    
      <category term="RoseLand" scheme="http://www.cpphonor.cn/tags/RoseLand/"/>
    
  </entry>
  
  <entry>
    <title>What&#39;s Manacher?</title>
    <link href="http://www.cpphonor.cn/2018/09/16/Details-1-Algorithm-Manacher/"/>
    <id>http://www.cpphonor.cn/2018/09/16/Details-1-Algorithm-Manacher/</id>
    <published>2018-09-16T09:25:42.000Z</published>
    <updated>2018-10-16T13:53:32.665Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <hr=""><h3 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h3><p> 要回答这个问题，首先得先清楚，<code>中心扩展法</code>。在求解最大回文子串X的过程中，中心扩展法，选取一个位置 作为中心，向前向后”扩散”,以期找到第一个不同的字符，亦即边界。然而，由于当X的长度为奇数时，可以直接选用一个位置i作为中心，而X为偶数长度时，则显然需要以”一对字符”作为中心扩展…..此时，问题出现了两种情况，都需要考虑，计算量可以说翻了一番（<code>Google it?</code>）。</p><p>如果，找到的X都是奇数长度的串就好了…. 那样便只需要考虑一种情况…..</p><hr><h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><p>Manacher 通过 将特殊字符（如$）插入到字符串的每相邻的两个字符中间，并在头尾也添加了该符号，保证了，找到的X必然是奇数长度串：</p><ul><li>找到的回文串头尾一定是 $，若将每一个 $ 都与紧跟着的下一个字符”配对”, 则最后的$刚好没法配对=&gt; 2n+1</li></ul><hr><p>现在，问题变为单情况的了，可以很容易地选择 当前位置 i 作为中心，扩散开来，求解最长X。</p><p>但是，这样就足够优化了吗，显然没有，因为很直观地就能看出来，我们一直在重复地做着中心位置左右两边的字符相等判定，从未复用之前判定的结果。如何复用，这就是Manacher的核心思想所在。</p><p>以字符串 ：aaaba 为例 </p><a href="http://ovge5llkw.bkt.clouddn.com/images/images/detail-1-manacher-string.jpg?imageView2/0/w/800/q/100|imageslim" title="string" class="gallery-item" target="_blank" rel="noopener"><img alt="string" src="http://ovge5llkw.bkt.clouddn.com/images/images/detail-1-manacher-string.jpg?imageView2/0/w/800/q/100|imageslim"></a><p>(为了使问题更清晰，使串T字符下标由1开始，可以考虑在串首加一个另外的特殊字符如 $#a#a#a#b#a# )</p><p>其中，Len[i]为 以串T 第i个字符为中心，求得的最大回文串长度，很有趣的一点：Len[i]-1刚好为原串的最大回文串长度。如 Len[3]-1= 3-1 = len(“aa”)可知，只需求得所有的Len[i], 即可得到最大的回文子串长度。</p><hr><h3 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h3><p>现在的问题变为：如何快速地算出Len[i]的值。</p><a href="http://ovge5llkw.bkt.clouddn.com/images/images/detail-1-Manacher-Algorithm.jpg?imageView2/0/w/800/q/100|imageslim" title="精髓所在(图片来自网络)" class="gallery-item" target="_blank" rel="noopener"><img alt="精髓所在(图片来自网络)" src="http://ovge5llkw.bkt.clouddn.com/images/images/detail-1-Manacher-Algorithm.jpg?imageView2/0/w/800/q/100|imageslim"></a><p>当 i &lt; R 时：</p><p>设以C为中心，回文 可扩展到R处【即R’R为现今最大回文子串】，则在C-R范围内，任意一个i（扩散中心）, 都有与之对称 i’。i’ 的最大回文长度为Len[i’]。 对于 i 只有两种情况</p><ul><li>若<code>Len[i]&lt;R-i</code> ,即 D&lt;R-i，则<code>Len[i&#39;]&lt;R-i</code>, 即，i’的回文串全部包含在C的回文串中，根据回文串性质，i的回文串也都在C中,区域刚好与i’串关于C对称！即 Len[i] 可以直接看出 -&gt; 刚好等于Len[i’]</li><li>若<code>Len[i]≥R-i</code>, 即 D≥R-i,  则此时，i扩散出去的边界位置将可能超过R，即 至少 “区域R-i” 包括在i 的回文串中, Len[i]可以从R-i处开始继续扩散。</li></ul><p>可知，<code>Len[i] ≥ min{Len[i&#39;], R-i}</code></p><p>当 i ≥ R 时：</p><p>无法对Len[i]的值做出推断，此时，将Len[i]置位初始值 1 （’字符i’ 必然回文 :-)）</p><hr><p>简易实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">manacher</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">    str = str.replaceAll(<span class="string">""</span>,<span class="string">"#"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> R = <span class="number">1</span>;<span class="comment">//回文串 右边界</span></span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">1</span>;<span class="comment">//回文串 中心</span></span><br><span class="line">    <span class="keyword">int</span> len = str.length()-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>[] L = <span class="keyword">new</span> <span class="keyword">int</span>[len+<span class="number">1</span>];</span><br><span class="line">    L[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> maxIdx = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> longest = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">2</span>*id-i;<span class="comment">// (i'+i)/2 = id =&gt; j=i'=2*id-i</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; R)&#123;</span><br><span class="line">            L[i] = Math.min(L[j],R-i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= R)&#123;</span><br><span class="line">            L[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//中心扩散</span></span><br><span class="line">        <span class="keyword">while</span>(i-L[i]&gt;=<span class="number">0</span> &amp;&amp; i+L[i]&lt;=len )&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(i+L[i]) == str.charAt(i-L[i]))&#123;</span><br><span class="line">                L[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(R&lt;i+L[i]-<span class="number">1</span>)&#123;</span><br><span class="line">            id = i;</span><br><span class="line">            R = i+L[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(L[i]&gt;longest)&#123;</span><br><span class="line">            longest = L[i];</span><br><span class="line">            maxIdx = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Arrays.sort(L);</span><br><span class="line">    <span class="keyword">int</span> maxlen = L[L.length-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> str.substring(maxIdx-maxlen+<span class="number">1</span>,maxIdx+maxlen).replaceAll(<span class="string">"#"</span>,<span class="string">""</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot;&gt;&lt;div class=&quot;.article-g
      
    
    </summary>
    
      <category term="The-Detail-CH.Algorithm" scheme="http://www.cpphonor.cn/categories/The-Detail-CH-Algorithm/"/>
    
    
      <category term="基础篇" scheme="http://www.cpphonor.cn/tags/%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    
      <category term="Detail系列" scheme="http://www.cpphonor.cn/tags/Detail%E7%B3%BB%E5%88%97/"/>
    
      <category term="RoseLand" scheme="http://www.cpphonor.cn/tags/RoseLand/"/>
    
  </entry>
  
  <entry>
    <title>浅谈-Https</title>
    <link href="http://www.cpphonor.cn/2018/04/17/%E6%B5%85%E8%B0%88Https/"/>
    <id>http://www.cpphonor.cn/2018/04/17/浅谈Https/</id>
    <published>2018-04-17T09:01:37.000Z</published>
    <updated>2018-04-17T09:39:56.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <blockquote=""><blockquote><p>在夹缝中寻求转机…</p><footer><strong>[No Name]</strong></footer></blockquote><a id="more"></a><hr><h3 id="首先-为何需要Https"><a href="#首先-为何需要Https" class="headerlink" title="首先 为何需要Https?"></a>首先 为何需要Https?</h3><p> 看情况，有些情况下确实不需要Https，它耗费较多的计算资源（加密解密）也好，资金（购买证书的花费）也罢，在不需要安全传输的时候，不用反而更自在。但是 当你要交换一些私人的重要信息（如密码）时，那就得考虑一下Https 了。</p><hr><h3 id="接下来谈谈历史…"><a href="#接下来谈谈历史…" class="headerlink" title="接下来谈谈历史…."></a>接下来谈谈历史….</h3><p>原先，大家都使用http，然后，有一天，有人发现可以轻松地截获http，然后窥探其中的内容，甚至修改其中的内容，给原先通信的双方带来威胁。问题既然出现了，那就解决它咯。</p><p>有人想出了一种感觉不错的方案：让通信双方协商一种加密规则（<code>对称密钥</code>），每次发送信息时都先经过这一规则进行加密，接收端进行解密 获取最终信息，这样 就算<code>中间人</code>截获了请求，也不知道里面的内容該如何解析。</p><p>然而，很快就被发现其中的缺陷，那就是，通信双方可能在 交换密钥的时候，就被截取了请求，中间人知道了密钥，甚至将密钥偷偷换成自己的，然后 同时和通信双方 用自己的伪造密钥 进行通信。</p><hr><p>又有人想到，是否可以使用<code>非对称的加密</code>，即 通信双方都保留一个<code>密钥对</code>，一个公钥，一个私钥，公钥发送给对方，让对方使用公钥进行加密，自己再用私钥进行解密。</p><p>然而，还是有上述的问题（中间人只要将其中双方发给对方的公钥都换成自己的公钥就行）。。。因为，<strong>根本的问题并没有被解决，就是如何将 对称密钥 或者 自己的公钥 正确地交到对方手上？ http请求很难避免被截获， 我们只能从另一个方向努力，即 让中间人就算截获到请求也不知道内容是什么，还有一旦中间人更改了请求的内容，通信方能够感知到。</strong></p><hr><p>首先有人想到的是 使用 <code>证书</code>，它由一个可信赖的第三方来颁发，证书中包含公钥和通信方的信息。这样，通过第三方来证明 和A通信的确实是B 而不是C。 不错的想法，然而还是没能解决问题，因为中间人可能成功篡改证书，那么证书有没有都没差了。。。</p><hr><p>后来，有人发现有一类 <code>hash算法</code>（常见MD5/SHA1/SHA256） 可以基于 某些信息 生成一个<code>消息摘要</code>。使用这种hash算法，一旦信息发生了改变，生成的消息摘要便会 大不相同【单向不可逆、对输入非常敏感、输出长度固定】。哦噢，这可大有可为了。如果用它来加密证书中的信息，那么便不用担心证书被修改了吧？ 然而，还是天真了，如果将整个信息全部替换，用一样的hash算法伪造一个新的消息摘要，那么通信的另一方还是无法辨别真伪（毕竟他主要通过同样的hash算法基于 证书信息 生成消息摘要，再对比消息摘要的异同）。。。何解？</p><hr><p>前面提到了 一个 可信赖的第三方，他们一般被称为 <code>CA(Certification Authority)</code>, 他们提出了一种方案，首先，服务器方应向他们申请 证书（赚钱的套路），内容可以是 基于 公钥+服务器方的一些必要信息【后面简称为原始数据】生成的消息摘要。申请成功，CA便会用他们的私钥对消息摘要进行签名，服务器方将签名结果加在原始数据后面【称为<code>数字签名</code>】，一起发给客户端。<strong>客户端接收到这个数据包后，首先，使用CA的公钥对 签名结果 进行解密，还原出消息摘要MS1 ,  然后 使用同样的hash算法 基于 原始数据 生成消息摘要 MS2, 只要MS1与MS2相同，那么便可以认定 原始数据未被修改过。。。</strong></p><blockquote><p>再问：客户端是如何获取 CA的公钥的？<br>一般主流的浏览器/操作系统中都会先内置 主流/顶级 的CA的公钥。</p></blockquote><hr><h3 id="着眼于-效率"><a href="#着眼于-效率" class="headerlink" title="着眼于 效率"></a>着眼于 效率</h3><p>OK, 安全问题到此基本解决了，我们可以稍稍放心使用https来保证我们的通信安全了。</p><p>但是，非对称加密的效率问题仍在困扰着人们。 通常的方案是使用非对称加密传输来交换 对称密钥:</p><pre><code>1. 服务端 通过上述方式（数字签名），成功将自己的公钥交付到客户端2. 客户端 （随机或者其他方式）生成一个用于后续数据交换的对称密钥，用服务端传过来的公钥 对此信息进行加密，然后发送给服务端。3. 服务端 用自己的私钥解密 得到 对称密钥，之后和客户端使用該密钥进行数据交换。</code></pre><p>整体的流程 如下图所示:(图片来源网络)</p><a href="http://ovge5llkw.bkt.clouddn.com/images/https1.png?imageView2/0/w/800/q/100|imageslim" class="gallery-item" target="_blank" rel="noopener"><img class="tcp-pic" src="http://ovge5llkw.bkt.clouddn.com/images/https1.png?imageView2/0/w/800/q/100|imageslim"></a><hr><p>度过了 夹杂欣喜、劳累、茫然、紧张、空洞 的一个月时间，平复一下心情，重新回到轨道上来 …</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot;&gt;&lt;div class=&quot;.article-gallery&quot; &lt;blockquote=&quot;&quot;&gt;
&lt;blockquote&gt;&lt;p&gt;在夹缝中寻求转机…&lt;/p&gt;
&lt;footer&gt;&lt;strong&gt;[No Name]&lt;/strong&gt;&lt;/footer&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="WEB安全" scheme="http://www.cpphonor.cn/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="Https" scheme="http://www.cpphonor.cn/tags/Https/"/>
    
  </entry>
  
  <entry>
    <title>You Don&#39;t Know JS 上卷(Ⅲ) 归纳</title>
    <link href="http://www.cpphonor.cn/2018/03/18/YouDontKnowJS-3/"/>
    <id>http://www.cpphonor.cn/2018/03/18/YouDontKnowJS-3/</id>
    <published>2018-03-18T13:31:17.000Z</published>
    <updated>2018-03-18T14:04:16.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <blockquote=""><blockquote><p>待你准备万全时, 机会往往已经悄然离去 …</p><footer><strong>[No name]</strong></footer></blockquote><a id="more"></a><hr><h2 id="一-对象"><a href="#一-对象" class="headerlink" title="一.对象"></a>一.对象</h2><hr><h3 id="1-1-类型："><a href="#1-1-类型：" class="headerlink" title="1.1.类型："></a>1.1.类型：</h3><p> 六种主要原始类型 string,number,boolean,null,undefined,object</p><pre><code>typeof(null);//object 这是JavaScript的一个bug,并不是说null是一种对象类型，null本身是基本类型原因是 不同的对象在底层都被表示为二进制，前三位均为0的化会被判定为object类型，null二进制表示为全0，故执行typeof返回‘object’</code></pre><h3 id="1-2-内置对象（JS的对象子类型）"><a href="#1-2-内置对象（JS的对象子类型）" class="headerlink" title="1.2.内置对象（JS的对象子类型）"></a>1.2.内置对象（JS的对象子类型）</h3><p>  内置对象 : String,Number,Boolean,Object,Function,Array，Date,RegExp,Error </p><pre><code>1.在JS中，它们只是一些内置函数，可当成构造函数，构造一个对应子类型的新对象【可通过typeof(**);返回&apos;function&apos;】2.不可能直接对字面量进行访问属性、方法的操作，var s=&quot;China&quot;; s.length;//可行，只是因为引擎将字面量&quot;China&quot;自动转换成了String对象3.null和undefined只有字面量形式，无构造形式，Date则只有构造形式，无文字形式4.Oject,Array,Function,RegExp无论使用文字形式还是构造形式，都是对象，不是字面量5.Error一般在抛出异常是自动创建，可以显式创建但基本不用</code></pre><h3 id="1-3-内容：-属性"><a href="#1-3-内容：-属性" class="headerlink" title="1.3.内容：(属性)"></a>1.3.内容：(属性)</h3><pre><code>1.对象容器中一般只存有属性的名，它指向对象的真正存储位置（如同指针或者说引用）2.属性访问：‘.’只能接受满足标准命名规范的属性，而‘[..]’可使用字符串访问，只需属于UTF-8/Unicode字符集3.对象中的属性名永远都是字符串，包括数字，也会先被转换为字符串4.ES6中新增了可计算属性名： var prefix=&quot;foo&quot;; var obj={[prefix+&quot;bar&quot;]:&quot;hello&quot;}; obj[&quot;foobar&quot;];//hello5.数组的属性名为数字 0,1,2... 如：(3 in [1,2,3])；//false 因为[1,2,3]只有属性0,1,2</code></pre><h3 id="1-4-属性与方法"><a href="#1-4-属性与方法" class="headerlink" title="1.4.属性与方法"></a>1.4.属性与方法</h3><pre><code>1.无论访问的返回值是什么类型，都是属性访问2.属性访问返回一个函数，那么这个函数等同于普通函数（除了可能的this隐式绑定），不是特属于該对象的所谓“方法”.3.foo和obj.foo的区别可能仅仅是obj.foo中的this可能被隐式绑定到对象obj,JS中没有“属性的方法”之说。4.ES6开始支持直接在对象中声明一个函数表达式，然而尽管如此該函数也不会“属于”这个对象</code></pre><h3 id="1-5-对象的复制"><a href="#1-5-对象的复制" class="headerlink" title="1.5.对象的复制"></a>1.5.对象的复制</h3><pre><code>1.浅复制:ES6定义了Object.assign(tagobj,srcobj1,...);     它会遍历一个或多个源对象的所有可枚举(enumerable)的自有键(owned key)，将他们复制(使用“=”)到目标对象，而后返回目标对象     由于使用的是=操作符赋值，故源对象的一些特性如writable不会被复制到tagobj     复制的只有值，引用还是原来的引用2.深复制:仍然有很多问题待解决，因为对于深复制来说，除了复制值，还会复制引用，引用的值，这可能造成死循环     对于JSON安全的对象来说，var newObj=JSON.parse(JSON.stringify(someObj));     【JSON安全：可被序列化为一个JSON字符串，并且可根据这个字符串解析出一个结构和值完全一样的对象】</code></pre><h3 id="1-6-属性描述符"><a href="#1-6-属性描述符" class="headerlink" title="1.6.属性描述符"></a>1.6.属性描述符</h3><p>  ES5以后JS开始支持直接检查属性特性的方法，具备了属性描述符</p><pre><code>1.查看：Object.getOwnPropertyDescriptor(obj,&quot;attr&quot;);2.添加或者修改属性：Object.defineProperty(obj,&quot;attr&quot;,{value:..,writable:..,configurable:..,enumerable:..});  - writable:可写性  - configurable:可配置性，一旦设置为false，不可更改（设置是单向的），其他属性也不可更改，甚至不能删除                [例外：writable可从true改为false,反之不成立]  - enumerable:可枚举性：可出现在对象属性的遍历中（for..in）3.delete不同于在C++中可以释放内存，它在JS中只是一个删除对象属性的操作   删除可删除的属性，若该属性是对某个对象/函数的最后一个引用，则删除之后，該对象/函数可被垃圾回收</code></pre><h3 id="1-7-不变性"><a href="#1-7-不变性" class="headerlink" title="1.7.不变性"></a>1.7.不变性</h3><pre><code>1.对象常量：结合writable:false和configurable:false即可2.禁止扩展：Object.preventExtensions(obj);//禁止对象添加新属性，并保留已有属性3.密封：Object.seal(obj);它会在现有对象上调用(2.)的方法并将configurable设为false  -密封后，不能添加新属性，也不能重新配置或者删除现有属性，可以修改属性的值(若writable:true)4.冻结：Object.freeze(obj);在线有对象上调用Object.seal()并将writable设为false;</code></pre><h3 id="1-8-getter与setter"><a href="#1-8-getter与setter" class="headerlink" title="1.8.getter与setter"></a>1.8.getter与setter</h3><pre><code>1.例：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj6=&#123;</span><br><span class="line">  get a()&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">this</span>._a_;</span><br><span class="line">  &#125;,</span><br><span class="line">  set a(val)&#123;</span><br><span class="line">     <span class="keyword">this</span>._a_=val;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>2.当[[get]]一个属性时，会先访问现对象obj的属性，找不到会到obj的原型链中去找，再找不到返回undefined3.[[put]]需要结合当前obj的属性描述符考虑</code></pre><h3 id="1-9-存在性"><a href="#1-9-存在性" class="headerlink" title="1.9.存在性"></a>1.9.存在性</h3><pre><code>1.in : 会再对象的原型链中找，(&quot;a&quot; in obj6)返回true2.Object.prototype.hasOwnProperty(..) 仅在当前对象中寻找  对象需要连接到Object.prototype,大多数对象都满足，除了空对象即Object.create(null);创建的  空对象obj可通过显式绑定Object.prototype.hasOwnProperty.call(obj,&quot;a&quot;);将hasOwnProperty方法到obj上3.枚举： -1.obj.propertyIsEnumerable(&quot;attr&quot;);检查给定的属性名是否直接存在于对象中(即不包含原型链),且满足enumberbal -2.Object.keys(..);返回一个包含所有可枚举属性的数组（对象中） -3.Object.getOwnPropertyNames(..);返回一个包含所有属性的数组，无论是否可枚举（对象中）</code></pre><h3 id="1-10-遍历"><a href="#1-10-遍历" class="headerlink" title="1.10.遍历"></a>1.10.遍历</h3><pre><code>1.for..in.. 遍历对象的属性，还需根据属性取得对应的值;2.ArrayObj.forEach(function(){...});对每一个数组元素调用一次回调函数,并忽略所有返回值;3.ArrayObj.every(带返回值的回调函数);运行直到回调函数返回false【无返回值默认返回false】4.ArrayObj.some(带返回值的回调函数);运行直到回调函数返回true;【无返回值，则返回fasle,即相当于遍历一遍数组】5.for..of.. 可直接遍历数组的值 for(var i of arr){..} -1.工作流程：(使用@@iterator手动遍历数组) <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="string">"A"</span>,<span class="string">"B"</span>];</span><br><span class="line"><span class="keyword">var</span> it=arr[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"><span class="comment">//arr[Symbol.iterator]取得数组对象的"Symbol.iterator"(即@@iterator)属性的值：一个返回迭代器的函数</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next());<span class="comment">//&#123;value:A,done:false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next());<span class="comment">//&#123;value:B,done:false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next());<span class="comment">//&#123;value:undefined,done:true&#125;</span></span><br></pre></td></tr></table></figure> -2.数组有内置的@@iterator,因此for..of可直接应用在数组上 -3.ES6中可用Symbol.iterator获取对象的@@iterator内部属性，@@iterator本身并非一个迭代器对象而是一个“返回迭代器对象的函数”！ -4.普通的非内置得对象，没有内置@@iterator,故无法自动完成for..of 需要自定义： <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line"> a:<span class="number">1</span>,</span><br><span class="line"> b:<span class="number">2</span>,</span><br><span class="line"> [<span class="built_in">Symbol</span>.iterator]:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self=<span class="keyword">this</span>; <span class="comment">//对象本身</span></span><br><span class="line">    <span class="keyword">var</span> attrs=<span class="built_in">Object</span>.keys(self);<span class="comment">//对象所有属性</span></span><br><span class="line">    <span class="keyword">var</span> i=<span class="number">0</span>;<span class="comment">//遍历下标</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      next:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span>&#123;</span><br><span class="line">          value:self[attrs[i++]],</span><br><span class="line">      done:(i&gt;attrs.length)</span><br><span class="line">    &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></code></pre><blockquote><p>关于 混合对象 “类”<br>[在JavaScript中模拟类是得不偿失的，虽然能解决当前的问题，然而可能埋下更多隐患]</p></blockquote><hr><h2 id="二-原型"><a href="#二-原型" class="headerlink" title="二.原型"></a>二.原型</h2><hr><h3 id="2-0-链"><a href="#2-0-链" class="headerlink" title="2.0.链"></a>2.0.链</h3><pre><code>函数对象才有prototype属性，实例对象.prototype为undefined对象的__proto__如同一个指针，指向它的构造函数的prototype对象，它串起了原型链Object.getPrototypeOf(myobj)===myobj.__proto__;</code></pre><h3 id="2-1-Prototype"><a href="#2-1-Prototype" class="headerlink" title="2.1.[[Prototype]]"></a>2.1.[[Prototype]]</h3><p>几乎所有对象在创建之时会被赋予一个[[Prototype]]的非空对象，它会关联到另一个对象</p><pre><code>1.var obj=Object.create(anotherobj);//创建一个新的对象，并将其[[Prototype]]关联到anotherobj2.对象通过[[Prototype]]的关联形成一条原型链，其顶端为Object.prototype,即所有普通对象的[[Prototype]]链最终都会指向Object.prototype3.属性访问设置和屏蔽：   -1.若在当前对象找不到某属性，则沿着它的原型链向上找，直到顶端，没有则返回undefined   -2.属性设置：obj.foo=&quot;bar&quot;;     -2.1.若foo同时存在于当前obj中和原型链中，则obj的foo属性会屏蔽原型链上层所有的foo,将当前obj.foo设置为&quot;bar&quot;;     -2.2.若foo仅存在于原型链上层，则：         1.若該属性可写(writable:true),则直接在obj中添加一个foo的新属性并赋值&quot;bar&quot;         2.若该属性只读(writable:false),则无法修改该属性且无法在obj上创建屏蔽属性，在严格模式下会抛出错误，非严格则忽略该语句         3.若foo是一个setter，那么一定会调用这个setter,即不会为obj创建新属性     -2.3.若无论何种情况都想要为obj的foo属性(即使不存在)设置值，那么Object.defineProperty(..)是个很好的办法   -3.使用屏蔽方法得不偿失，应尽量避免使用</code></pre><h3 id="2-2-委托"><a href="#2-2-委托" class="headerlink" title="2.2.委托"></a>2.2.委托</h3><p>对象中没有某个属性，却可能能通过原型链获取该属性，这其实是一种委托，委托给原型链上别的对象帮忙实现</p><pre><code>1.JavaScript没有与其他语言类似的继承，即通过类复制行为，不管是创建对象或者定义子类2.JavaScript的“继承”，可以理解为一种“差异继承”或者“原型继承”，或者本不该有继承的说法，就只是委托3.即，不关心通用的共有的属性，定义的是差异的属性，因为共有的属性可通过原型链委托实现4.JavaScript中并没有复制机制，不可能创建一个“类”的多个实例，只能是创建多个对象并将它们的[[Prototype]]关联到同一个对象   没有从&quot;类&quot;中复制任何的行为到对象，只是让两个对象相互关联，而这样也能达成同样的效果(通过委托)</code></pre><h3 id="2-3-”-constructor”和”-prototype”"><a href="#2-3-”-constructor”和”-prototype”" class="headerlink" title="2.3.”.constructor”和”.prototype”"></a>2.3.”.constructor”和”.prototype”</h3><pre><code>0.JavaScript没有某个函数就是“构造函数”，var a=new Foo(&quot;a&quot;); Foo()本身是普通函数，然而被new调用后就成了一个“构造函数” -1.确切的说，是new的调用使得某个函数调用变成了“构造函数调用” -2.new会创建一个新的对象a（Foo内不返回对象时）,并将a.prototype关联到Foo.prototype对象1.a.constructor属性并非一定指向这个对象的构造函数，它是不可信的指向，因为可以将它修改以指向任意对象 -1.a.constructor===Foo;//true,实际上，a可能并没有.constructor属性，只是委托给了Foo.prototype,而Foo.prototype.constructor默认指向了Foo    当然Foo.prototype也不一定有constructor属性，此时会继续向上层委托    当然，没有可以自己通过Object.defineProperty(.,.,{})添加一个,注意此属性正常是不可枚举的enumberable:false -2.总之constructor的指向并无法令人信服地证明什么.2.var a=new Foo(..); Object.getPrototypeOf(a)===Foo.prototype;//true  -1.prototype是公有且不可枚举的属性 -2.通过new Foo(..)，新对象内部的[[Prototype]]关联到了Foo.prototype</code></pre><h3 id="2-4-将对象关联的方法"><a href="#2-4-将对象关联的方法" class="headerlink" title="2.4.将对象关联的方法"></a>2.4.将对象关联的方法</h3><p> 对于function Bar(..){..}  与 function Foo(..){..}</p><pre><code>1.为Bar创建一个新的prototype对象，关联到Foo.prototype,抛弃原始的关联对象(声明时Bar会关联到一个默认的对象)   Bar.prototype=Object.create(Foo.prototype);    有问题的方式:   -1.Bar.prototype=Foo.prototype;      它会直接让Bar.prototype引用Foo.prototype对象，当对Bar.prototype的属性进行修改时会直接修改Foo.prototype本身   -2.Bar.prorotype= new Foo(..);       基本可以满足需求，然而若是Foo有副作用(写日志、修改状态、给this添加数据属性..)，则会影响到Bar()的“后代”2.ES6开始，可使用Object.setPrototypeOf(Bar.prototype,Foo.prototype);//可直接修改Bar.prototype</code></pre><h3 id="2-5-关联判断"><a href="#2-5-关联判断" class="headerlink" title="2.5.关联判断"></a>2.5.关联判断</h3><p>  1.判断在a的整条原型链中是否有指向Foo.prototype的对象(a的原型链中是否出现过Foo.prototype)<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">-1.</span>a <span class="keyword">instanceof</span> Foo;<span class="comment">//true  instanceof操作符左操作数是一个普通对象，右操作数是一个函数</span></span><br><span class="line"><span class="number">-2.</span>Foo.prototype.isPrototypeOf(a);</span><br><span class="line"><span class="number">-3.</span>a.__proto__===Foo.prototype;<span class="comment">//绝大多数浏览器支持</span></span><br><span class="line">    .__proto__和常用的内置函数(toString(),isPrototypeOf()等)一样，存在于<span class="built_in">Object</span>.prototype中(而不在a中)，不可枚举</span><br><span class="line"><span class="number">-4.</span><span class="built_in">Object</span>.getPrototypeOf(a)===Foo.prototype;</span><br><span class="line"><span class="number">-5.</span>b.isPrototypeOf(c); b是否出现在c的原型链中</span><br></pre></td></tr></table></figure></p><p>[部分实现Object.create() :]<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!<span class="built_in">Object</span>.create)&#123;</span><br><span class="line">   <span class="built_in">Object</span>.create=<span class="function"><span class="keyword">function</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">     F.prototype=o;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h2 id="三-委托-“对象关联”的编写风格"><a href="#三-委托-“对象关联”的编写风格" class="headerlink" title="三.委托(“对象关联”的编写风格)"></a>三.委托(“对象关联”的编写风格)</h2><hr><p><strong> “对象关联” 的编写风格</strong> =&gt; <code>仅关注对象之间的关联联系</code></p><h3 id="3-1-委托理论"><a href="#3-1-委托理论" class="headerlink" title="3.1.委托理论"></a>3.1.委托理论</h3><pre><code>1.数据成员应保存在委托者中而不是委托目标上2.委托行为中，应尽量避免原型链的不同层级上使用相同的命名(不同于类模式的尽量同名以至于可重写，多态)3.充分利用this的隐式和显式绑定规则4.委托行为意味着，当某些对象找不到属性或者方法引用时会把这个请求委托给另一个对象 5.在API接口的设计中，委托应尽量在内部实现而不是暴露出去。6.互相委托是禁止的，即A关联到B时，试图将B再关联到A就会出错，不然可能会引发死循环</code></pre><h3 id="3-2-“类”与“委托”思维模型的比较"><a href="#3-2-“类”与“委托”思维模型的比较" class="headerlink" title="3.2.“类”与“委托”思维模型的比较"></a>3.2.“类”与“委托”思维模型的比较</h3><pre><code>1.类设计模式：(“原型”)面向对象风格 -1.主干是各原型对象组成的原型链，顶端为Object -2.枝叶是各“构造函数”，它们的prototype属性都指向一个原型对象   例 对于Foo(){}  对应 Foo.prototype对象 -3.行为应被添加到prototype对象中   例： Foo.prototype.identify=function(){} -4.每创建一个新对象，都应该将其prototype属性关联到一个上层[[prototype]]对象，以建立原型链  使用类似 Bar.prototype=Object.create(Foo.prototype)或者Object.setPrototypeOf(Bar.prototype,Foo.prototype)的方法创建新对象 -5.通过new进行构造函数调用，创建实例2.委托设计模式：对象关联风格 -1.仅关注并致力于对象之间的联系的创建，行为委托认为对象间是兄弟关系，互相委托 -2.主干是各原型对象组成的原型链，顶端是Object.prototype对象     行为集成在对象中，成为对象的属性。 -3.建立关联：Bar=Object.create(Foo);【让Bar委托Foo】 -4.向委托链上添加对象：var b1=Object.create(Bar);//亦是建立委托关联，本身是对象，无须实例化 -5.遵从委托理论进行设计</code></pre><hr><h2 id="TO-BE-CONTINUE-…"><a href="#TO-BE-CONTINUE-…" class="headerlink" title="TO BE CONTINUE …"></a>TO BE CONTINUE …</h2><p>　　沉迷 JavaScript 不能自拔,日渐消瘦… </p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot;&gt;&lt;div class=&quot;.article-gallery&quot; &lt;blockquote=&quot;&quot;&gt;
&lt;blockquote&gt;&lt;p&gt;待你准备万全时, 机会往往已经悄然离去 …&lt;/p&gt;
&lt;footer&gt;&lt;strong&gt;[No name]&lt;/strong&gt;&lt;/footer&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="深入理解JavaScript" scheme="http://www.cpphonor.cn/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JavaScript/"/>
    
      <category term="YouDon&#39;tKnowJS" scheme="http://www.cpphonor.cn/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JavaScript/YouDon-tKnowJS/"/>
    
    
      <category term="JavaScript" scheme="http://www.cpphonor.cn/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>You Don&#39;t Know JS 上卷(Ⅱ) 归纳</title>
    <link href="http://www.cpphonor.cn/2018/03/11/YouDontKonwJS-2/"/>
    <id>http://www.cpphonor.cn/2018/03/11/YouDontKonwJS-2/</id>
    <published>2018-03-11T15:51:49.000Z</published>
    <updated>2018-03-11T16:22:06.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <blockquote=""><blockquote><p>试着改变, 致力于完善 … </p><footer><strong>[No name]</strong></footer></blockquote><a id="more"></a><hr><h2 id="一-误解"><a href="#一-误解" class="headerlink" title="一.误解"></a>一.误解</h2><hr><h3 id="1-1-this指向函数本身"><a href="#1-1-this指向函数本身" class="headerlink" title="1.1.this指向函数本身"></a>1.1.this指向函数本身</h3>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>函数体内的<span class="keyword">this</span>并不一定指向函数本身，或者说，绝大部分情况下不指向函数本身</span><br><span class="line"><span class="number">2.</span>要指向函数本身，一般需要通过它的词法标识符，比如<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;&#125;，指向它本身，应使用foo.element;</span><br><span class="line"><span class="number">3.</span>对于匿名函数，要引用它自身，则需要使用atgument.callee,然而，这个方法已经被废弃，故应尽量避免使用匿名函数.</span><br><span class="line"> --或者说，在需要自引用的时候使用具名函数.</span><br><span class="line"><span class="number">4.</span>使用call可确保<span class="keyword">this</span>指向函数本身，如foo.call(foo,arg..);</span><br></pre></td></tr></table></figure><h3 id="1-2-this指向函的数作用域"><a href="#1-2-this指向函的数作用域" class="headerlink" title="1.2.this指向函的数作用域"></a>1.2.this指向函的数作用域</h3>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>有时确实如此，有时却不一定，但可以知道的是，<span class="keyword">this</span>不会指向函数的词法作用域</span><br><span class="line"><span class="number">2.</span>在JavaScript内部，作用域如同对象一般，所有的可见标识符都可以算作是它的属性</span><br><span class="line"><span class="number">3.</span>然而，作用域(词法)“对象”却无法通过JavaScript代码访问，它存在于JavaScript引擎内部</span><br><span class="line"><span class="number">4.</span>是故<span class="keyword">this</span>不可能指向函数的词法作用域,无法将<span class="keyword">this</span>与词法作用域的查找混合使用</span><br><span class="line"><span class="number">5.</span><span class="keyword">this</span>是在函数被调用时发生的[绑定],它指向哪里取决于她在哪里被调用！</span><br></pre></td></tr></table></figure><hr><h2 id="二-解析"><a href="#二-解析" class="headerlink" title="二.解析"></a>二.解析</h2><hr><h3 id="2-1-调用位置（正在执行的函数被调用的位置）"><a href="#2-1-调用位置（正在执行的函数被调用的位置）" class="headerlink" title="2.1.调用位置（正在执行的函数被调用的位置）"></a>2.1.调用位置（正在执行的函数被调用的位置）</h3>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>分析调用栈(链)，即为到达当前执行位置所调用的所有函数。</span><br><span class="line"><span class="number">2.</span>调用位置即为当前正在执行的函数的<span class="string">'前一个调用'</span>中</span><br></pre></td></tr></table></figure><h3 id="2-2-绑定位置"><a href="#2-2-绑定位置" class="headerlink" title="2.2.绑定位置"></a>2.2.绑定位置</h3><pre><code>1.默认绑定，严格模式下不可用,不带任何修饰的独立函数调用  绑定到undefined或者全局对象取决于 [函数体]是否处于严格模式2.隐式绑定：与调用位置的上下文对象有关，或者说释放被某个对象包含,例：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(a);&#125;  <span class="keyword">var</span> obj=&#123;<span class="attr">a</span>:<span class="number">2</span>,<span class="attr">foo</span>:foo&#125;;  obj.foo(); <span class="comment">//2 </span></span><br><span class="line"><span class="comment">//this被绑定到了obj上下文</span></span><br></pre></td></tr></table></figure> 2.1.对于对象属性引用链，只有最靠近当前foo的一层(最后一层)会影响调用位置,如<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj2=&#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">obj</span>:obj&#125;; obj2.obj.foo();<span class="comment">//2   </span></span><br><span class="line">即obj2不会影响foo的调用位置。</span><br></pre></td></tr></table></figure> 2.2.隐式丢失：将obj.foo作为回调函数，或者使用一个别名【var bar=obj.foo; bar();】,会造成隐式丢失     此时，被引用的会是foo函数本身，即this绑定到了全局对象或者undefined 2.3.有时甚至，回调函数会修改this,比如将它绑定到触发事件的DOM元素上 2.4.回调函数中，this的改变常常意想不到，需要通过 固定this来解决这些问题3.显示绑定：call和apply方法 3.1.绝大多数函数都可以使用这两个方法，无论JS提供的或者自己定义的 3.2.call()第一个参数接受一个对象，this就绑定到这个对象     若传入的是一个原始值，则这个原始值会先被“装箱”，即new String(...) or new Boolean(..) 等 3.3.若只是这样，那还是无法解决绑定的丢失问题，可使用“硬绑定”，即强制绑定   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//(1).创建一个包裹函数，传入所有的参数并返回接收到的所有值</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> bar=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> foo.apply(obj,<span class="built_in">arguments</span>); &#125;; bar(<span class="number">3</span>);</span><br><span class="line"><span class="comment">//(2).创建一个可以重复使用的辅助函数</span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">bind</span>(<span class="params">func,obj</span>)</span>&#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line"> <span class="keyword">return</span> func.apply(obj,<span class="built_in">arguments</span>); </span><br><span class="line"> &#125;;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">var</span> bar=bind(foo,obj);  </span><br><span class="line"> bar(<span class="number">3</span>);</span><br><span class="line"><span class="comment">//(3).ES5的内置方法bind()，bind(..)会返回一个硬编码的新函数，它将传入的参数设置为this的上下文</span></span><br><span class="line"> <span class="keyword">var</span> bar=foo.bind(obj);  bar(<span class="number">3</span>);</span><br></pre></td></tr></table></figure> 3.4.许多第三方库函数和内置函数，都提供一个可选参数--context【上下文】,作用同bind(),如   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].forEach(foo,obj); </span><br><span class="line"><span class="comment">//调用foo时将this绑定到obj 本质上还是显示绑定，只是内部实现了</span></span><br></pre></td></tr></table></figure>4.new绑定 4.1.JavaScript的new与其他语言有很大不同 4.2.构造函数是使用new操作符是被调用的普通函数，它们不会属于某个类，也不会实例化一个类 4.3.起始并不存在真正意义上的“构造函数”，只能说是“函数的构造调用” 4.4.new调用函数时，会自动执行以下操作：  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//(1).创建一个全新的对象并对其执行“原型链接”</span></span><br><span class="line"><span class="comment">//(2).将新对象绑定到函数调用的this.</span></span><br><span class="line"><span class="comment">//(3).如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象,例：</span></span><br><span class="line"><span class="keyword">var</span> bar=<span class="keyword">new</span> foo(<span class="number">2</span>); <span class="built_in">console</span>.log(bar.a); <span class="comment">//2; </span></span><br><span class="line"><span class="comment">//会构造一个新对象并将它绑定到foo(..)调用中的this上</span></span><br></pre></td></tr></table></figure>5.优先级：默认绑定 &lt; 隐式 &lt; 显式 &lt; new 5.1.若硬绑定函数被new调用，则会使用新创建的this替换硬绑定的this 5.2.new中使用硬绑定函数，其主要目的是预先设置函数的一些参数，这样在使用new初始化是就以只传入其余的参数 5.3.应用到了bind()函数的“部分应用(柯里化【预先设置一些参数】的一种)”技术，即将除第一个以外的参数传给下层的函数。</code></pre><h3 id="2-3-判断this的一般步骤："><a href="#2-3-判断this的一般步骤：" class="headerlink" title="2.3.判断this的一般步骤："></a>2.3.判断this的一般步骤：</h3><p>  1.函数是否在new中调用(new绑定)？是则this绑定的是新创建的对象。<br>   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> foo();</span><br></pre></td></tr></table></figure></p><p>  2.函数是否通过call,apply(显式绑定)或者硬绑定调用?是则this绑定的是指定的对象<br>   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = foo.call(obj,arg..);  or <span class="keyword">var</span> bar = foo.bind(obj,arg..)</span><br></pre></td></tr></table></figure></p><p>  3.函数是否在某个上下文对象中调用(隐式绑定)？是则this绑定的就是該上下文对象<br>   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = obj.foo();</span><br></pre></td></tr></table></figure></p><p>  4.1、2、3全不适用，则严格模式下绑定到undefined,非严格模式绑定到全局对象(默认绑定)<br>   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = foo();</span><br></pre></td></tr></table></figure></p><h3 id="2-4-绑定例外"><a href="#2-4-绑定例外" class="headerlink" title="2.4.绑定例外"></a>2.4.绑定例外</h3><p>  1.对于apply,call,bind,传入null（为了展开参数或者柯里化）,作为绑定的上下文对象，则会使用默认绑定<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a,b</span>)</span>&#123;cosole.log(<span class="string">"a:"</span>+a+<span class="string">",b:"</span>+b);&#125;</span><br><span class="line">foo.apply(<span class="literal">null</span>,[<span class="number">2</span>,<span class="number">3</span>]);<span class="comment">//a:2,b:3 【将数组“展开”成参数，同ES6中的foo(...[2,3]);】</span></span><br><span class="line"><span class="keyword">var</span> bar=foo.bind(<span class="literal">null</span>，<span class="number">2</span>)；bar(<span class="number">3</span>);<span class="comment">//a:2,b:3【柯里化】</span></span><br></pre></td></tr></table></figure></p><p>  2.默认绑定是不安全的，因为可能绑定到全局对象，此时，有可能无意间修改了全局对象，造成难以预计的后果<br>  3.更安全的this:使foo绑定到一个真正的空对象 即创建一个”DMZ”(demilitarized)对象<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> DMZ=<span class="built_in">Object</span>.create(<span class="literal">null</span>); <span class="keyword">var</span> bar = foo.bind(DMZ,<span class="number">2</span>);</span><br></pre></td></tr></table></figure></p><h3 id="2-5-软绑定"><a href="#2-5-软绑定" class="headerlink" title="2.5.软绑定"></a>2.5.软绑定</h3><p>  1.硬绑定大大降低了函数的灵活性，使用硬绑定后就无法使用隐式绑定或者显式绑定修改this的能力<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!<span class="built_in">Function</span>.prototype.sofeBind)&#123;</span><br><span class="line">  <span class="built_in">Function</span>.prototype.softBind=<span class="function"><span class="keyword">function</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> fn=<span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">//捕获所有的curried参数</span></span><br><span class="line">    <span class="keyword">var</span> curried=[].slice.call(<span class="built_in">arguments</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">var</span> bound=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> fn.apply(</span><br><span class="line">         (!<span class="keyword">this</span>||(<span class="keyword">this</span>==global))?obj:<span class="keyword">this</span>,</span><br><span class="line">             curried.concat.apply(curried,<span class="built_in">arguments</span>)</span><br><span class="line">        );</span><br><span class="line">     &#125;;</span><br><span class="line">      bound.prototype=<span class="built_in">Object</span>.create(fn.prototype);</span><br><span class="line">     <span class="keyword">return</span> bound;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  2.软绑定sofebind()可为默认绑定自设定一个值，那么实现硬绑定的效果同时，还可以保留隐式绑定和显式绑定修改 this 的能力<br>  3.sofebind()首先会检查调用时的 this ,如果 this 绑定到 <code>global</code> 或者 <code>undefined</code>, 则将指定的 obj 绑定到 this, 否则不修改 this</p><hr><h2 id="三-this词法"><a href="#三-this词法" class="headerlink" title="三.this词法"></a>三.this词法</h2><hr><pre><code>3.1.ES6中的箭头函数不适用（2.3）中this的四条标准规则，而是根据外层作用域(函数或者全局)来决定this.3.2.function foo(){ return (a)=&gt;{console.log(this.a);}; } 则此时箭头函数的this继承自foo(),且該this绑定[无法修改]3.3.箭头函数用更常见的词法作用域取代了传统的this机制3.4.箭头函数的this绑定同传统的self=this差不多</code></pre><hr><h2 id="TO-BE-CONTINUE-…"><a href="#TO-BE-CONTINUE-…" class="headerlink" title="TO BE CONTINUE …"></a>TO BE CONTINUE …</h2><p>　　沉迷 JavaScript 不能自拔,日渐消瘦… </p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot;&gt;&lt;div class=&quot;.article-gallery&quot; &lt;blockquote=&quot;&quot;&gt;
&lt;blockquote&gt;&lt;p&gt;试着改变, 致力于完善 … &lt;/p&gt;
&lt;footer&gt;&lt;strong&gt;[No name]&lt;/strong&gt;&lt;/footer&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="深入理解JavaScript" scheme="http://www.cpphonor.cn/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JavaScript/"/>
    
      <category term="YouDon&#39;tKnowJS" scheme="http://www.cpphonor.cn/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JavaScript/YouDon-tKnowJS/"/>
    
    
      <category term="JavaScript" scheme="http://www.cpphonor.cn/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>You Don&#39;t Know JS 上卷(Ⅰ) 归纳</title>
    <link href="http://www.cpphonor.cn/2018/03/08/YouDontKnowJS-1/"/>
    <id>http://www.cpphonor.cn/2018/03/08/YouDontKnowJS-1/</id>
    <published>2018-03-08T12:13:34.000Z</published>
    <updated>2018-03-08T13:36:54.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <blockquote=""><blockquote><p>想的太多, 做的太少, 只会使你迷茫…</p><footer><strong>[No name]</strong></footer></blockquote><a id="more"></a><hr><h2 id="一-JavaScript的编译执行"><a href="#一-JavaScript的编译执行" class="headerlink" title="一.JavaScript的编译执行"></a>一.JavaScript的编译执行</h2><hr><h3 id="1-1-演员-引擎，编译器，作用域"><a href="#1-1-演员-引擎，编译器，作用域" class="headerlink" title="1.1.演员 : 引擎，编译器，作用域"></a>1.1.演员 : 引擎，编译器，作用域</h3><pre><code>- 1.编译器对代码进行分词（或词法化）并解析（抽象语法树），并将其中的变量名注册到作用域（在当前作用域中还未存在的）- 2.编译器通过AST生成可执行代码- 3.引擎对变量（标识符，包括函数）进行LHS（待赋值空间）和RHS（查变量源值）查询【在作用域中】（此阶段为引擎对代码的编译阶段）- 4.当引擎在当前作用域中查询不到想要的东西时，他会去查询上一级作用域，直至全局。（作用域嵌套情况，由此也可知内层会覆盖外层作用域变量）  - 1.对于RHS查询，若在所有的作用域中都找不到变量，则抛出ReferenceError(引用异常);  - 2.对于LHS查询，找不到则会创建一个并返回给引擎，前提是在“非严格模式”下,否则同RHS.  - 3.是故区别RHS和LHS很重要。- 5.若查询成功，接下来，若是对变量操作非法，如对非函数类型进行函数调用，则会抛出TypeError.</code></pre><h3 id="1-2-作用域模型"><a href="#1-2-作用域模型" class="headerlink" title="1.2.作用域模型"></a>1.2.作用域模型</h3><pre><code>- 1.JavaScript使用词法作用域，另一种模型是动态作用域模型（Bash,Perl）;- 2.词法作用域一般根据词法关系保持书写时的自然关系不变;- 3.一个作用域不能包含于两个外作用域;  - 4.欺骗词法:修改作用域[eval]或创建新作用域[with]    - 1.eval(..)接受一个字符串str为参数，将str视作原本就存在于该位置【eval()所在】的代码（类似于inline）       //通过eval，可能隐蔽地在内部声明一个与外层作用域同名的变量，从而覆該变量。       //类似的有new Function(..)  - 2.with:  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例：</span></span><br><span class="line"><span class="keyword">var</span> obj=&#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:<span class="number">2</span>,<span class="attr">c</span>:<span class="number">3</span>&#125;; <span class="keyword">with</span>(obj)&#123;a=<span class="number">2</span>;b=<span class="number">3</span>;c=<span class="number">4</span>;&#125; </span><br><span class="line"><span class="comment">/*即通过with可优雅地重复地引用同一对象obj的多个属性。</span></span><br><span class="line"><span class="comment"> * with可将一个对象处理为完全隔离的词法作用域（即凭空创建了一个新的词法作用域：with函数作用域）</span></span><br><span class="line"><span class="comment"> * 当with块中的变量赋值时，若作用域链中找不到該变量，则可能将其添加到全局作用域(非严格模式下)，从而污染全局空间*/</span></span><br></pre></td></tr></table></figure>- 5.欺骗词法会带来不确定性，从而，引擎编译时难以优化甚而不优化，会严重降低执行效率，应尽量少用。- 6.可将作用域模型比作一座大楼，第一层就是当前作用域，顶层就是全局作用域  - 1.每一层中的标识符优先级都是同等的。</code></pre><p>补:【词法作用域关注函数在何处声明，而动态作用域关注的时函数从何处调用(this机制亦是如此)】</p><hr><h2 id="二-函数作用域与块作用域"><a href="#二-函数作用域与块作用域" class="headerlink" title="二.函数作用域与块作用域"></a>二.函数作用域与块作用域</h2><hr><h3 id="2-1-函数作用域"><a href="#2-1-函数作用域" class="headerlink" title="2.1.函数作用域"></a>2.1.函数作用域</h3><pre><code>- 1.每个函数块都会创建一个该层的作用域，该层包含此函数中所有的标识符（当然，不包括内层函数中的标识符）  1.内层函数可以访问外层函数，因为外层函数的作用域在它的“楼上”.  2.也因此，需要保护外层的变量，它们可能被内层破坏性地进行非法操作。- 2.通过一个函数包裹，隐藏内部实现（变量与函数），或者内层声明与外层同名的标识符，覆盖外层  - 1.将所有仅期望被当前一个或几个函数访问的变量，同这几个函数一起用一个外层函数包裹起来，保护它们不被全局中另外的内层函数破坏性操作。  - 2.符合最小暴露原则  - 3.可规避冲突        1.当加载了多个第三方库的时候，库会在全局作用域中声明一个独特的变量(通常是一个对象)，用作库的命名空间。        2.所有需要暴露给外界的功能都会成为这个对象的属性(可通过obj.attr访问)        3.这样該库的命名空间就不会被污染，内部的变量函数也不会被其他的库或者内层函数非法操作，也不会与其他库命名冲突。        4.就如同在全局作用域与库之间加了一个夹层，以供保护。  - 4.类似的有模块管理，可保持私有，无冲突的作用域（通过依赖管理器的机制）- 3.闭包（function foo(参数){}）(外部参数);  - 1.区分函数声明与函数表达式: 在整个声明中，function为第一个词，则为函数声明，否则为函数表达式.  - 2.闭包的第一个()使其被解释为一个函数表达式.  - 3.第二个()使該函数表达式立即执行，可传入外部参数     <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.若不传入参数，亦可以写成（function foo()&#123;&#125; () ）;</span></span><br><span class="line"><span class="comment">//2.可将外部的对象当作参数传入，将其改成一个较为合理的标识符</span></span><br><span class="line"><span class="comment">//如：</span></span><br><span class="line"> (<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">global</span>)</span>&#123;...&#125;)(<span class="built_in">window</span>)</span><br><span class="line"><span class="comment">//3.妙用：(function foo(undefined)&#123;&#125;)();不传入参数，因此，形参undefined就真的成了undefined</span></span><br></pre></td></tr></table></figure>- 4.匿名与具名，行内表达式  - 1.函数表达式可以匿名，但函数声明不行（另一个区分声明与表达式的方法）  - 2.匿名函数书写和使用简单便捷，在库和工具中应用广泛，用作回调函数亦是非常常见。  - 3.缺点        1.匿名函数不易调试，因为没有有意义的函数名        2.在递归中，引用自身使需要使用已过期的arguments.callee引用        3.可读性不高  - 4.行内表达式，它具备匿名函数的所有优点        1.行内表达式，匿名与具名没有影响        2.行内表达式应该具名，以规避匿名函数的缺点。</code></pre><h3 id="2-2-块作用域"><a href="#2-2-块作用域" class="headerlink" title="2.2.块作用域"></a>2.2.块作用域</h3><pre><code>- 1.with语句块，with从对象创建出的作用域仅在with声明有效- 2.try/catch中的catch分句亦会创建一个块作用域，一个catch创建一个，其中的标识不会泄露到外层。- 3.let关键字：  - 1.let可将变量绑定到所在的任意作用域（块）中，通常在{...}内部  - 2.可通过{..}为let创建一个 用于绑定的块  - 3.需要时刻注意哪些块作用域中有绑定的变量，尽量避免将这些块移动或包含在其他的块中，否则可能导致代码混乱。  - 4.解决(3.)中的问题，通过(2.)的方法，即为块作用域显示地创建块    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例：</span></span><br><span class="line"><span class="keyword">var</span> foo=<span class="literal">true</span>; </span><br><span class="line"><span class="keyword">if</span>(foo)&#123; </span><br><span class="line">    &#123; <span class="keyword">let</span> bar=foo*<span class="number">2</span>; <span class="built_in">console</span>.log(bar); &#125;<span class="comment">/*【显式的块】*/</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此时，整个显式的块都可以方便地移动而不会对外部的if声明的位置和语义造成影响。</span></span><br></pre></td></tr></table></figure>  - 5.let声明不会对变量进行提升，即“变量声明处”之后才可以使用  - 6.let其他作用：垃圾回收，let循环- 4.const:创建值固定的块作用域变量</code></pre><h3 id="2-3-提升"><a href="#2-3-提升" class="headerlink" title="2.3.提升"></a>2.3.提升</h3><pre><code>- 1.在每个作用域中，函数和变量的声明会被提升，赋值（包括函数表达式的赋值）等操作则被留在原地等待执行。- 2.函数提升的优先级高于变量。(两者同名的情况)- 3.提升发生在编译阶段  - 例：var a=2; 被编译为 var a;  a=2; 一个发生在编译阶段，一个在执行阶段</code></pre><hr><h2 id="三-闭包"><a href="#三-闭包" class="headerlink" title="三.闭包"></a>三.闭包</h2><hr><h3 id="3-1-何为闭包"><a href="#3-1-何为闭包" class="headerlink" title="3.1.何为闭包"></a>3.1.何为闭包</h3><p>当函数（内层函数）能记住并访问所在的词法作用域时，就产生了闭包.</p><pre><code>- 1.内层函数Inner能访问外层函数Outer的词法作用域，将該Inner传递到外部(词法作用域之外)，它就持有对原作用域的引用，这个引用就是闭包。- 2.无论使用何种传递方式将Inner传递到外部为B-Inner，当在外部执行B-Inner时，就使用了闭包。- 3.B-Inner保存了Inner的原作用域的引用，因此Outer的中的“资源”不会被垃圾回收，可供B-Inner使用，直到B-Inner释放。</code></pre><h3 id="3-2-闭包的使用"><a href="#3-2-闭包的使用" class="headerlink" title="3.2.闭包的使用"></a>3.2.闭包的使用</h3><p>在定时器、事件监听、Ajax请求、跨窗口通信、Web Worker或者其他的异步（或同步）任务中，只要使用了回调函数，实际上就在使用闭包。</p><h3 id="3-3-立即执行函数表达式-IIFE"><a href="#3-3-立即执行函数表达式-IIFE" class="headerlink" title="3.3.立即执行函数表达式(IIFE)"></a>3.3.立即执行函数表达式(IIFE)</h3><p>IIFE确实创建了闭包，也是最常用来创建被封闭起来的闭包的工具</p><pre><code>- 1.然而它本身并不使用闭包的方式查询得到相应的词法作用域中的变量，反而常常使用普通的词法作用域查找就能找到需要的变量。- 2.循环中的IIFE,若要保存for循环的值i,者需要将其引入到IIFE创建的作用域中，否则作用域仍然为空：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例：</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123; </span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        setTimeout（<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(i)&#125;,<span class="number">1000</span>*i）</span><br><span class="line">    &#125;)(); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//IIFE只会是一个空作用域，需要将i作为参数传入，或者在IIFE内定义一个变量接受i的值。</span></span><br><span class="line"><span class="comment">//【每次迭代都会创建一个新的作用域】</span></span><br></pre></td></tr></table></figure></code></pre><h3 id="3-4-let在闭包应用上的作用"><a href="#3-4-let在闭包应用上的作用" class="headerlink" title="3.4.let在闭包应用上的作用"></a>3.4.let在闭包应用上的作用</h3><pre><code>- 1.let绑定了一个块作用域,即{..}，該作用域是可封闭的，可作为闭包的块作用域，let j=i;则此时就保留了每次循环的i值- 2.for(let i=1;.....){...} for循环头部的let声明会有一个特殊的行为  - 1.该行为支出变量在循环过程中不止被声明一次，而是每次迭代都会声明  - 2.随后的每个迭代都会使用上一轮迭代结束时的值来初始化这个变量  - 3.这亦能起到闭包作用- 3.即 let帮闭包绑定了一个块作用域以供使用</code></pre><h3 id="3-5-模块-闭包的一个强大应用"><a href="#3-5-模块-闭包的一个强大应用" class="headerlink" title="3.5.模块, 闭包的一个强大应用"></a>3.5.模块, 闭包的一个强大应用</h3><pre><code>- 1.必须要有外部的封闭函数如CoolModule()，该函数必须至少被调用一次(每次调用都会创建一个新的模块实例)- 2.封闭函数必须返回至少一个内部函数（公共API），这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态  - 1.可通过字典方式如 return {key:funName,...};   - 2.或先保留公共API对象的内部引用，在返回該引用：var publicAPI={key:funName,...}; return publicAPI;- 3.通过var foo=CoolModule(); foo.apifunc1(); foo.apifunc2();- 4.当然也可以定义可接受参数的模块，模块也是普通的函数。- 5.ES6中开始使用import导入（从别的模块导入当前），export导出（从当前模块导出） API成员  - ES6中模块没有“行内”格式，只能一个文件定义一个模块</code></pre><hr><h2 id="TO-BE-CONTINUE-…"><a href="#TO-BE-CONTINUE-…" class="headerlink" title="TO BE CONTINUE …"></a>TO BE CONTINUE …</h2><p>　　沉迷 JavaScript 不能自拔,日渐消瘦…</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot;&gt;&lt;div class=&quot;.article-gallery&quot; &lt;blockquote=&quot;&quot;&gt;
&lt;blockquote&gt;&lt;p&gt;想的太多, 做的太少, 只会使你迷茫…&lt;/p&gt;
&lt;footer&gt;&lt;strong&gt;[No name]&lt;/strong&gt;&lt;/footer&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="深入理解JavaScript" scheme="http://www.cpphonor.cn/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JavaScript/"/>
    
      <category term="YouDon&#39;tKnowJS" scheme="http://www.cpphonor.cn/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JavaScript/YouDon-tKnowJS/"/>
    
    
      <category term="JavaScript" scheme="http://www.cpphonor.cn/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>深入理解 React - 1</title>
    <link href="http://www.cpphonor.cn/2018/02/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-React-1/"/>
    <id>http://www.cpphonor.cn/2018/02/26/深入理解-React-1/</id>
    <published>2018-02-26T09:41:56.000Z</published>
    <updated>2018-03-08T13:39:52.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <blockquote=""><blockquote><p>知行合一</p><footer><strong>[Yangming Wang]</strong></footer></blockquote><a id="more"></a><hr><h2 id="先谈-DOM的更新"><a href="#先谈-DOM的更新" class="headerlink" title="先谈 DOM的更新"></a>先谈 DOM的更新</h2><hr><p>前端的优化中，效果明显的便是减少DOM的操作，而DOM的操作为何开销很大？</p><blockquote><p>浏览器首先根据 CSS 规则查找匹配的节点，这个过程会缓存很多元信息，例如它维护着一个对应 DOM 节点的 <code>id</code> 映射表。<br>然后，根据样式计算节点布局，这里又会缓存位置和屏幕定位信息，以及其他很多的元信息，浏览器会尽量避免重新计算布局，所以这些数据都会被缓存。</p><p>计算展现样式的过程会吃掉很多CPU周期。我们可以先减轻浏览器渲染引擎的负担，然后提升UI的响应速度，在组件视图里，使用对渲染引擎依赖更小的技术。</p></blockquote><p><code>核心问题</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DOM 修改导致的页面 repaint(重绘)、reflow(重排)！ reflow是用户阻塞的操作，同时，如果频繁重排，CPU 使用率也会猛涨！</span><br><span class="line">为了确保执行结果的准确性，所有的修改操作是按顺序同步执行的。大部分浏览器都不会在JavaScript的执行过程中更新DOM。相应的，这些浏览器将对对 DOM的操作放进一个队列，并在JavaScript脚本执行完毕以后按顺序一次执行完毕。也就是说，在JavaScript执行的过程，直到发生重新排版，用户一直被阻塞。</span><br><span class="line">一般的浏览器中（不含IE），repaint的速度远快于reflow，所以避免reflow更重要。</span><br><span class="line"></span><br><span class="line">导致repaint、reflow的操作：</span><br><span class="line"></span><br><span class="line">    * DOM元素的添加、修改（内容）、删除( Reflow + Repaint)</span><br><span class="line"></span><br><span class="line">    * 仅修改DOM元素的字体颜色（只有Repaint，因为不需要调整布局）</span><br><span class="line"></span><br><span class="line">    * 应用新的样式或者修改任何影响元素外观的属性</span><br><span class="line"></span><br><span class="line">    * Resize浏览器窗口、滚动页面</span><br><span class="line"></span><br><span class="line">    * 读取元素的某些属性（offset[Left| Top| Height| Width]、scroll[Top| Left| Width| Height]、client[Top| Left| Width| Height]、getComputedStyle()...)</span><br></pre></td></tr></table></figure><p>解决问题的关键是：减少因DOM操作，引起的reflow: (<code>批量</code> 与 <code>缓存</code> + <code>隐藏节点特性</code>)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1 . 在DOM外，执行尽量多的变更操作</span></span><br><span class="line"><span class="keyword">var</span> fragment = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; items.length; i++)&#123;</span><br><span class="line">    <span class="keyword">var</span> item = <span class="built_in">document</span>.createElement(<span class="string">"li"</span>);</span><br><span class="line">    item.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">"Option "</span> + i);</span><br><span class="line">    fragment.appendChild(item);</span><br><span class="line">&#125;</span><br><span class="line">list.appendChild(fragment);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2 . 操作DOM前，先把DOM节点删除或隐藏，因为隐藏的节点不会触发重排</span></span><br><span class="line">list.style.display = <span class="string">"none"</span>;  </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; items.length; i++)&#123;  </span><br><span class="line">    <span class="keyword">var</span> item = <span class="built_in">document</span>.createElement(<span class="string">"li"</span>);  </span><br><span class="line">    item.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">"Option "</span> + i);  </span><br><span class="line">    list.appendChild(item);  </span><br><span class="line">&#125;  </span><br><span class="line">list.style.display = <span class="string">""</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//3 . 一次性，修改样式属性</span></span><br><span class="line">.newStyle &#123;  </span><br><span class="line">    background-color: blue;  </span><br><span class="line">    color: red;  </span><br><span class="line">    font-size: <span class="number">12</span>em;  </span><br><span class="line">&#125;  </span><br><span class="line">element.className = <span class="string">"newStyle"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4 . 使用缓存，缓存临时节点</span></span><br><span class="line"><span class="keyword">var</span> myDiv = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>);  </span><br><span class="line">myDiv.style.left = myDiv.offsetLeft + myDiv.offsetWidth + <span class="string">"px"</span>;</span><br></pre></td></tr></table></figure><p><strong>无论如何优化，通过 “发起DOM更新” 的方法更新视图的方法总会产生一次次的reflow与repaint，因此是否可以换个思路，即不再修改原本的DOM，而是直接将它替换！也可以说是 “仅一次的DOM更新“。</strong></p><p>这个思路来源于PHP:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在 PHP 中，每当有数据改变时，只需要跳到一个由 PHP 全新渲染的新页面即可。</span><br><span class="line">从开发者的角度来看的话，这种方式开发应用是非常简单的，因为它不需要担心变更，且界面上用户数据改变时所有内容都是同步的。</span><br><span class="line">只要有数据变更，就重新渲染整个页面,简单粗暴。</span><br><span class="line">但是 它 非常慢!</span><br></pre></td></tr></table></figure><p>JS 若直接采用此种方法，当任何内容改变时，都<strong>重新构建</strong>整个 DOM，然后用新 DOM 取代旧 DOM ，那么在某些情况下可能会发生一些问题: 比如它会失去当前聚焦的元素和光标，以及文本选择和页面滚动位置，即<code>页面的当前状态</code>。<strong>DOM 节点是包含状态的, 且还包含隐藏、无法触及的状态</strong>。</p><p>若想在新DOM中还原旧DOM中的所有状态，难以实现或几乎无法实现。因此还得换个思路来保留原有状态。</p><p>有效可行的方案便是：<code>复用未改变的节点，替换改变过的节点</code></p><p>而此时，问题的关键点就转换到如何识别出DOM的变动节点</p><hr><h2 id="Diff算法"><a href="#Diff算法" class="headerlink" title="Diff算法"></a>Diff算法</h2><hr><p>在React中，构建UI界面的思路是由当前状态决定界面。前后两个状态就对应两套界面，然后由React来比较两个界面的区别，这就需要对DOM树进行Diff算法分析。即:</p><ul><li>给定任意两棵树，找到最少的转换步骤。</li></ul><p>但是 <code>标准的的Diff算法</code> 复杂度需要O(n^3)，这显然无法满足性能要求。要达到每次界面都可以整体刷新界面的目的，势必需要对算法进行优化。</p><p>这看上去非常有难度，然而Facebook工程师却做到了，他们结合Web界面的特点做出了几个简单的假设，使得Diff算法复杂度直接降低到O(n) 【diff算法详见:<a href="https://zhuanlan.zhihu.com/p/20346379" target="_blank" rel="noopener">不可思议的 React Diff</a> 】</p><ul><li>两个相同组件产生类似的DOM结构，不同的组件产生不同的DOM结构；</li><li>对于同一层次的一组子节点，它们可以通过唯一的id进行区分。</li><li>Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计</li></ul><p>Diff算法总的来说就是完成下述操作:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 对比新旧DOM树，当节点不同，则直接删去该节点及其子节点，用新的节点代替。这应用了第1、3个假设，不同的组件一般会产生不一样的DOM结构，与其浪费时间去比较它们基本上不会等价的DOM结构，还不如完全创建一个新的组件加上去。</span><br><span class="line">* React 逐层进行节点比较，即两棵树只会对同一层次的节点进行比较（同一父节点的所有子节点为一层）</span><br></pre></td></tr></table></figure><p>这样，一次DOM树遍历便可完成比较，即O(n)。</p><p>然而，又如何比较两个节点是否相同或不同呢 ? 这又是一个问题.</p><p>通过元素名称？名称最可能相同</p><p>节点属性？似乎可行，但是需要是id属性这样独一无二的才有通用的可能。考虑表单的情况，输入一般与id挂钩，但是当使用ajax提交表单时…显然此时我们一般不给input等属性设置id.因此，这个还是不通用。</p><p>引入一个专门的属性是最好的方法之一（可能还有其他方案），React引入了key属性，用于辅助Diff算法（<strong>这也是为什么在 React 中使用列表时会要求给子元素设置 key 属性的原因</strong>）</p><p>简单来说当子节点们 key属性相同时，无需进行删除创建操作，可进行节点移动操作或不操作。</p><hr><h2 id="VirtualDOM"><a href="#VirtualDOM" class="headerlink" title="VirtualDOM"></a>VirtualDOM</h2><hr><p>DOM节点拥有大量的属性，对他的操作（特别是查询和创建）将耗费大量资源。 React 只在 diff 算法中用到了 DOM 节点，而且只用到了标签名称和部分属性。<br>如果用更<strong>轻量级</strong>的 JS 对象来代替复杂的 DOM 节点，然后把对 DOM 的 diff 操作转移到 JS 对象，就可以避免大量对 DOM 的查询操作。这种方式称为 Virtual DOM 。</p><p>其过程如下: <a href="https://segmentfault.com/a/1190000013365426?utm_source=channel-hottest#articleHeader8" target="_blank" rel="noopener">详见 - React是怎样炼成的</a></p><ol><li>维护一个使用 JS 对象表示的 Virtual DOM，与真实 DOM 一一对应</li><li>对前后两个 Virtual DOM 做 diff ，生成<strong>变更</strong>（Mutation）</li><li>把变更应用于真实 DOM，生成最新的真实 DOM</li></ol><p><a href="https://sfault-image.b0.upaiyun.com/304/368/3043688841-5a9175107a171_articlex" title="img" class="gallery-item" target="_blank" rel="noopener"><img src="https://sfault-image.b0.upaiyun.com/304/368/3043688841-5a9175107a171_articlex" alt="img"></a></p><hr><p>参考:</p><p>深入浅出React  (四) <a href="http://www.infoq.com/cn/articles/react-dom-diff/" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/react-dom-diff/</a></p><p>React是怎样练成的 <a href="https://segmentfault.com/a/1190000013365426?utm_source=channel-hottest" target="_blank" rel="noopener">https://segmentfault.com/a/1190000013365426?utm_source=channel-hottest</a></p><hr></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot;&gt;&lt;div class=&quot;.article-gallery&quot; &lt;blockquote=&quot;&quot;&gt;
&lt;blockquote&gt;&lt;p&gt;知行合一&lt;/p&gt;
&lt;footer&gt;&lt;strong&gt;[Yangming Wang]&lt;/strong&gt;&lt;/footer&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="深入理解React系列" scheme="http://www.cpphonor.cn/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3React%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="JavaScript" scheme="http://www.cpphonor.cn/tags/JavaScript/"/>
    
      <category term="React" scheme="http://www.cpphonor.cn/tags/React/"/>
    
      <category term="DOM" scheme="http://www.cpphonor.cn/tags/DOM/"/>
    
  </entry>
  
  <entry>
    <title>Configuring-Nginx</title>
    <link href="http://www.cpphonor.cn/2017/11/11/Configuring-Nginx/"/>
    <id>http://www.cpphonor.cn/2017/11/11/Configuring-Nginx/</id>
    <published>2017-11-11T13:50:46.000Z</published>
    <updated>2017-11-30T13:04:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <blockquote=""><blockquote><p>事业的达成<br>必要的是正确有意义的目标<br>   其次得确保其可行性<br>   最后还得未雨绸缪</p><footer><strong>[Zhou Aimin]</strong></footer></blockquote><hr><h2 id="——-BEGIN-——"><a href="#——-BEGIN-——" class="headerlink" title="—— BEGIN ——"></a>—— BEGIN ——</h2><hr><h2 id="Nginx-的优化措施"><a href="#Nginx-的优化措施" class="headerlink" title="Nginx 的优化措施"></a>Nginx 的优化措施</h2><h3 id="三类事件"><a href="#三类事件" class="headerlink" title="三类事件"></a>三类事件</h3><p>　　一个基本的 web 服务器需要处理的事件的大概可分为三类：网络事件，信号处理，定时器。</p><a id="more"></a><h4 id="网络事件"><a href="#网络事件" class="headerlink" title="网络事件"></a>网络事件</h4><p>　　异步非阻塞处理模型: 多进程，单线程,全局监控的任务队列(类似epoll)</p><pre><code>1. 分 master 进程和 worker 进程，master监管，每个worker处理一个事件，多个workder间不互相影响2. 避免了无谓的上下文切换（一般在多线程的切换过程），避免了cpu资源的竞争(进程数不宜过多，一般为核数)</code></pre><h4 id="信号处理"><a href="#信号处理" class="headerlink" title="信号处理"></a>信号处理</h4><p>　　特殊的信号会有特别的意义，信号会中断掉当前程序的运行，在改变状态后，继续执行. 如果是系统调用，则可能会导致系统调用的失败，需要重入.</p><pre><code>1. 对于 nginx 来说，如果 nginx 正在等待事件（epoll_wait）时，如果程序收到信号，在信号处理函数处理完后, epoll_wait会返回错误，然后程序可再次进入 epoll_wait 调用。</code></pre><h4 id="定时器事件"><a href="#定时器事件" class="headerlink" title="定时器事件"></a>定时器事件</h4><p>　　由于 epoll_wait 等函数在调用的时候是可以设置一个超时时间的，所以 nginx 借助这个超时时间来实现定时器.</p><pre><code>1. nginx 里面的定时器事件是放在一颗维护定时器的红黑树里面，每次在进入 epoll_wait 前，先从该红黑树里面拿到所有定时器事件的最小时间，在计算出 epoll_wait 的超时时间后进入epoll_wait。2. 当没有事件产生，也没有中断信号时，epoll_wait会超时，也就是说，定时器事件到了。这时，nginx会检查所有的超时事件，将他们的状态设置为超时，然后再去处理网络事件。3. 当我们写nginx代码时，在处理网络事件的回调函数时，通常做的第一个事情就是判断超时，然后再去处理网络事件。</code></pre><hr><h2 id="指令上下文"><a href="#指令上下文" class="headerlink" title="指令上下文"></a>指令上下文</h2><p>　　nginx.conf 中的配置信息，根据其逻辑上的意义，对它们进行了分类，也就是分成了多个作用域，或者称之为配置指令上下文。不同的作用域含有一个或者多个配置项。</p><h3 id="当前nginx支持的指令上下文"><a href="#当前nginx支持的指令上下文" class="headerlink" title="当前nginx支持的指令上下文"></a>当前nginx支持的指令上下文</h3><pre><code>1. main:         nginx在运行时与具体业务功能（比如 http 服务或者 email 服务代理）无关的一些参数比如工作进程数，运行的身份等。2. http:        与提供 http 服务相关的一些配置参数。例如：是否使用 keepalive 啊，是否使用 gzip 进行压缩等。3. server:         http 服务上支持若干虚拟主机。每个虚拟主机一个对应的 server 配置项，配置项里面包含该虚拟主机相关的配置。在提供 mail 服务的代理时，也可以建立若干 server.每个 server 通过监听的地址来区分。4. location:    http服务中，某些特定的URL对应的一系列配置项。5. mail:         实现email相关的 SMTP/IMAP/POP3 代理时，共享的一些配置项（因为可能实现多个代理，工作在多个监听地址上）。</code></pre><p>指令上下文, 可能有包含的情况出现，例如: 通常 http 上下文和 mail 上下文一定是出现在 main 上下文里的。<br>在一个上下文里，可能包含另外一种类型的上下文多次，例如：如果 http 服务，支持了多个虚拟主机，那么在 http 上下文里，就会出现多个 server 上下文。</p><p>我们来看一个示例配置：(来源网络-侵删)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">user  nobody;</span><br><span class="line">worker_processes  1;</span><br><span class="line">error_log  logs/error.log  info;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen          80;</span><br><span class="line">        server_name     www.linuxidc.com;</span><br><span class="line">        access_log      logs/linuxidc.access.log main;</span><br><span class="line">        location / &#123;</span><br><span class="line">            index index.html;</span><br><span class="line">            root  /var/www/linuxidc.com/htdocs;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen          80;</span><br><span class="line">        server_name     www.renginx.com;</span><br><span class="line">        access_log      logs/renginx.access.log main;</span><br><span class="line">        location / &#123;</span><br><span class="line">            index index.html;</span><br><span class="line">            root  /var/www/renginx.com/htdocs;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mail &#123;</span><br><span class="line">    auth_http  127.0.0.1:80/auth.php;</span><br><span class="line">    pop3_capabilities  &quot;TOP&quot;  &quot;USER&quot;;</span><br><span class="line">    imap_capabilities  &quot;IMAP4rev1&quot;  &quot;UIDPLUS&quot;;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen     110;</span><br><span class="line">        protocol   pop3;</span><br><span class="line">        proxy      on;</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen      25;</span><br><span class="line">        protocol    smtp;</span><br><span class="line">        proxy       on;</span><br><span class="line">        smtp_auth   login plain;</span><br><span class="line">        xclient     off;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这个配置中，上面提到个五种配置指令上下文都存在。</p><p>存在于main上下文中的配置指令如下:</p><pre><code>-user     -worker_processes    -error_log-events   -http                -mail</code></pre><p>存在于http上下文中的指令如下:</p><pre><code>-server</code></pre><p>存在于mail上下文中的指令如下：</p><pre><code>-server-auth_http-imap_capabilities</code></pre><p>存在于server上下文中的配置指令如下：</p><pre><code>-listen    -server_name        -access_log        -location-protocol  -proxy           -smtp_auth      -xclient</code></pre><p>存在于location上下文中的指令如下：</p><pre><code>-index-root</code></pre><hr><h2 id="服务器静态动态配置"><a href="#服务器静态动态配置" class="headerlink" title="服务器静态动态配置"></a>服务器静态动态配置</h2><h3 id="Nginx反向代理集群配置"><a href="#Nginx反向代理集群配置" class="headerlink" title="Nginx反向代理集群配置"></a>Nginx反向代理集群配置</h3><p>配置 location 为 tomcat 集群<br>① upstream可以为每个设备设置状态值，这些状态值的含义分别如下 :</p><pre><code>down ：表示单前的 server 暂时不参与负载.weight ：默认为1.weight越大，负载的权重就越大。max_fails ：允许请求失败的次数默认为1.当超过最大次数时，返回 proxy_next_upstream 模块定义的错误.fail_timeout : max_fails 次失败后，暂停的时间。backup ： 其它所有的非 backup 机器 down 或者忙的时候，请求 backup 机器。所以这台机器压力会最轻。    </code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">upstream tomcats&#123;</span><br><span class="line">      server 127.0.0.1:9001 down;</span><br><span class="line">      server 127.0.0.1:9002 backup;</span><br><span class="line">      server 127.0.0.1:9003 weight=2;</span><br><span class="line">      server 127.0.0.1:9004 max_fails=2 fail_timeout=60s;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>② 分配策略 :</p><ol><li><p>none（轮询）<br>upstream 按照轮询（默认）方式进行负载，每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器 down 掉，能自动剔除。虽然这种方式简便、成本低廉。但缺点是：可靠性低和负载分配不均衡。</p></li><li><p>weight（权重）<br>指定轮询几率，weight 和访问比率成正比，用于后端服务器性能不均的情况。例如</p><p> server 192.168.61.22 weight = 6; # 60% 请求<br> server 192.168.61.23 weight = 4; # 40% 请求</p></li><li><p>ip_hash（访问ip）<br>每个请求按访问 ip 的 hash 结果分配，这样每个访客固定访问一个后端服务器，可以解决 session 的问题。<br>配置只需要在 upstream 中加入 ip_hash;即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream tomcats &#123;</span><br><span class="line">      ip_hash;</span><br><span class="line">      server 127.0.0.1:9001;</span><br><span class="line">      server 127.0.0.1:9002;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>fair（第三方）<br>按后端服务器的响应时间来分配请求，响应时间短的优先分配。与 weight 分配策略类似。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream tomcats &#123;</span><br><span class="line">      server 127.0.0.1:9001;</span><br><span class="line">      server 127.0.0.1:9002;</span><br><span class="line">      fair;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>url_hash（第三方）<br>和IP哈希类似，只不过针对请求的 url 进行 hash（基于缓存的 server，页面静态化）。</p></li></ol><p>③配置实例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">upstream tomcats &#123;</span><br><span class="line">    server <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9001</span>;</span><br><span class="line">    server <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9002</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen <span class="number">80</span>;</span><br><span class="line">    server_name  www.****.com;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass_header Server;</span><br><span class="line">        proxy_set_header Host $http_host;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header X-Scheme $scheme;</span><br><span class="line">        proxy_pass http:<span class="comment">//tomcats;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h3 id="Nginx-静态资源分离部署"><a href="#Nginx-静态资源分离部署" class="headerlink" title="Nginx 静态资源分离部署"></a>Nginx 静态资源分离部署</h3><p>修改 nginx.conf 文件，用于 nginx 处理静态资源。</p><p>主要配置如下(在 server 配置中加入 location 配置即可)：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       <span class="number">80</span>;</span><br><span class="line">    server_name  <span class="number">123.45</span><span class="number">.123</span><span class="number">.45</span>;</span><br><span class="line">    charset utf<span class="number">-8</span>;</span><br><span class="line">    index index.html index.htm index.jsp index.do;</span><br><span class="line">    root /opt/nginx-master/html/resources;</span><br><span class="line"></span><br><span class="line">    #配置 Nginx 动静分离，定义的静态页面直接从Nginx发布目录读取。</span><br><span class="line">    location ~ .*\.(html|htm|gif|jpg|jpeg|bmp|png|ico|txt|js|css)$ </span><br><span class="line">    &#123;</span><br><span class="line">        root /opt/nginx-master/html/resources;</span><br><span class="line">        #expires定义用户浏览器缓存的时间为7天，如果静态页面不常更新，可以设置更长，这样可以节省带宽和缓解服务器的压力</span><br><span class="line">        expires      <span class="number">7</span>d; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="本地动静分离反向代理配置"><a href="#本地动静分离反向代理配置" class="headerlink" title="本地动静分离反向代理配置"></a>本地动静分离反向代理配置</h3><p>所有jsp的页面均交由 tomcat 或 resin 处理<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location ~ .(jsp|jspx|<span class="keyword">do</span>)?$ &#123;</span><br><span class="line">proxy_set_header Host $host;</span><br><span class="line">proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">proxy_pass http:<span class="comment">//127.0.0.1:8080;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>所有静态文件由 nginx 直接读取不经过 tomcat 或 resin<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location ~ .*.(htm|html|gif|jpg|jpeg|png|bmp|swf|ioc|rar|zip|txt|flv|mid|doc|ppt|pdf|xls|mp3|wma)$&#123;</span><br><span class="line">expires <span class="number">15</span>d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ~ .*.(js|css)?$&#123; </span><br><span class="line">expires <span class="number">1</span>h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h2 id="——-END-——"><a href="#——-END-——" class="headerlink" title="—— END ——"></a>—— END ——</h2></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot;&gt;&lt;div class=&quot;.article-gallery&quot; &lt;blockquote=&quot;&quot;&gt;
&lt;blockquote&gt;&lt;p&gt;事业的达成&lt;br&gt;必要的是正确有意义的目标&lt;br&gt;   其次得确保其可行性&lt;br&gt;   最后还得未雨绸缪&lt;/p&gt;
&lt;footer&gt;&lt;strong&gt;[Zhou Aimin]&lt;/strong&gt;&lt;/footer&gt;&lt;/blockquote&gt;

&lt;hr&gt;
&lt;h2 id=&quot;——-BEGIN-——&quot;&gt;&lt;a href=&quot;#——-BEGIN-——&quot; class=&quot;headerlink&quot; title=&quot;—— BEGIN ——&quot;&gt;&lt;/a&gt;—— BEGIN ——&lt;/h2&gt;&lt;hr&gt;
&lt;h2 id=&quot;Nginx-的优化措施&quot;&gt;&lt;a href=&quot;#Nginx-的优化措施&quot; class=&quot;headerlink&quot; title=&quot;Nginx 的优化措施&quot;&gt;&lt;/a&gt;Nginx 的优化措施&lt;/h2&gt;&lt;h3 id=&quot;三类事件&quot;&gt;&lt;a href=&quot;#三类事件&quot; class=&quot;headerlink&quot; title=&quot;三类事件&quot;&gt;&lt;/a&gt;三类事件&lt;/h3&gt;&lt;p&gt;　　一个基本的 web 服务器需要处理的事件的大概可分为三类：网络事件，信号处理，定时器。&lt;/p&gt;
    
    </summary>
    
      <category term="Web Server" scheme="http://www.cpphonor.cn/categories/Web-Server/"/>
    
      <category term="Configuration" scheme="http://www.cpphonor.cn/categories/Web-Server/Configuration/"/>
    
    
      <category term="Configure" scheme="http://www.cpphonor.cn/tags/Configure/"/>
    
      <category term="Nginx" scheme="http://www.cpphonor.cn/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>深入理解TCP-传输控制</title>
    <link href="http://www.cpphonor.cn/2017/11/07/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP-%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6/"/>
    <id>http://www.cpphonor.cn/2017/11/07/深入理解TCP-传输控制/</id>
    <published>2017-11-07T05:43:40.000Z</published>
    <updated>2017-11-30T13:18:10.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <blockquote=""><blockquote><p>为有源头活水来…</p><footer><strong>[Zhu Xi]</strong></footer></blockquote><blockquote><p>2017-11-19 2rd</p></blockquote><h2 id="BEGIN"><a href="#BEGIN" class="headerlink" title="BEGIN"></a>BEGIN</h2><hr><h2 id="可靠传输基础"><a href="#可靠传输基础" class="headerlink" title="可靠传输基础"></a>可靠传输基础</h2><p> 序列号( SYN )与确认应答号( ACK ): </p><pre><code>1. 发送端发送某一 TCP 段, 需要清楚接收端是否成功接收这个 TCP段 ,  才能确定下一步是重新发送还是继续发送下一 TCP段.2. 接收端也需要清楚自己接收的是哪个 TCP段 , 才能决定下一步的工作(重复出错丢弃, 按需请求重发).3. TCP段 乱序到达, 需要知道如何正确排序.</code></pre><a id="more"></a><p> 序列号与确认应答提供了一个不错的实现.</p><p> 详细见 <a href="https://www.cpphonor.cn/2017/10/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP-%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E4%B8%8E%E6%96%AD%E5%BC%80/#more">深入理解TCP-连接建立与断开</a></p><h2 id="重发与窗口机制"><a href="#重发与窗口机制" class="headerlink" title="重发与窗口机制"></a>重发与窗口机制</h2><h3 id="为何需要重发"><a href="#为何需要重发" class="headerlink" title="为何需要重发:"></a>为何需要重发:</h3><h4 id="未成功接收-传输中丢失或因拥堵超时"><a href="#未成功接收-传输中丢失或因拥堵超时" class="headerlink" title="未成功接收(传输中丢失或因拥堵超时)"></a>未成功接收(传输中丢失或因拥堵超时)</h4><p> TCP数据段包裹在一个IP包中传输( you drop I drop ). IP包可能在网络中丢失, 比如:<br> 经过太多的路由器达到 hop limit or 路由器太过拥挤导致一些IP包被丢弃 or routing table没有及时更新…</p><h4 id="接收数据包出错"><a href="#接收数据包出错" class="headerlink" title="接收数据包出错"></a>接收数据包出错</h4><p> 接收端可以通过校验 TCP 数据段头部中 checksum 区域来检验 TCP 数据段是否出错.<br> TCP 数据段的 checksum 算法与 IP 包的 checksum 类似.不同的是:</p><blockquote><p>IP协议的 checksum 只校验头部,TCP数据段头部的 checksum 会校验包括 IP 头部、TCP 头部和 TCP 数据在内的整个序 列,确保 IP 地址、端口号和其他相关信息正确.<br> 如果 TCP 数据段出错, 接收方可以简单的丢弃該 TCP 数据段，也就相当于 TCP 数据段丢失.<br> 关于如何计算校验和,这里不进行深入研究…</p></blockquote><hr><h3 id="窗口机制"><a href="#窗口机制" class="headerlink" title="窗口机制"></a>窗口机制</h3><p>首先需要知道的是, TCP是以段为单位发送数据的, 段的长度称为最大消息长度MSS<br>TCP 传输大量数据时以 MSS 的大小将数据进行分割,重发时也以MSS为单位<br> MSS 在TCP连接建立的过程中(三次握手)由两端主机进行协商(告诉对方自己的接口能适应的MSS的大小),取较小值</p><h4 id="何为窗口控制"><a href="#何为窗口控制" class="headerlink" title="何为窗口控制?"></a>何为窗口控制?</h4><pre><code>使用大量 Buffer, 实现同时对多个段进行确认应答的功能,发送端主机未接收到确认应答也可以先发送下一个段.但是,在收到 ACK 前, 必须保证对应的段仍保存一份在缓存区, 以供重发.一旦收到 ACK ,相应的段就可以从缓存区中清除</code></pre><h4 id="为何要有窗口控制"><a href="#为何要有窗口控制" class="headerlink" title="为何要有窗口控制?"></a>为何要有窗口控制?</h4><pre><code>1.TCP 每发送一个段都得进行一次确认应答处理,则当 RTT 较长时,通信性能会很低效.2.考虑 TCP段 的确认应答未返回的情况:一种可能是 数据未能到达, 还有一种是接收端返回 ACK 然而途中丢失了...这种情况下, 若是没有窗口控制, 则这些未接收返回的 ACK 的数据包都会被重发.而有了窗口控制之后, 我们会发现, 即使中间丢失了一些确认应答也无妨:考虑到 若是 ACK:1001 ~ ACK:3001 均丢失了, 但我们接收到了ACK:4001, 那也间接表明了4001以前的数据段都已经成功接收.</code></pre><h4 id="发送窗口"><a href="#发送窗口" class="headerlink" title="发送窗口"></a>发送窗口</h4><p>发送窗口大小由接收端（流量控制）和底层网络的拥塞程度（拥塞控制）决定</p><a href="http://ovge5llkw.bkt.clouddn.com/images/20171108TCPsenderwindow.png?imageView2/0/w/800/q/100|imageslim" class="gallery-item" target="_blank" rel="noopener"><img class="tcp-pic" src="http://ovge5llkw.bkt.clouddn.com/images/20171108TCPsenderwindow.png?imageView2/0/w/800/q/100|imageslim"></a><hr><h4 id="接收窗口"><a href="#接收窗口" class="headerlink" title="接收窗口"></a>接收窗口</h4><p>TCP 允许接收进程以自己的速率拉数据.接收端的 部分被分配缓冲区 可以被已接收且确认,正在等待被接收进程”拉”的字节占据.<br>接收窗口大小总是小于或等于缓冲区大小, 它的大小决定了接收窗口在被淹没（流量控制）之前可以 从发送端接收的字节数.</p><a href="http://ovge5llkw.bkt.clouddn.com/images/20171108TCPrecvwindow.png?imageView2/0/w/800/q/100|imageslim" class="gallery-item" target="_blank" rel="noopener"><img class="tcp-pic" src="http://ovge5llkw.bkt.clouddn.com/images/20171108TCPrecvwindow.png?imageView2/0/w/800/q/100|imageslim"></a><hr><h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><p>　　收到序列号合法的确认应答的情况下,便可以将窗口滑动到确认应答中的序列号的位置,以顺序地将多个段同时发送提高通信性能.收到的确认应答号在范围之外或者校验出错时丢弃此ACK, 计时继续.</p><a href="http://ovge5llkw.bkt.clouddn.com/images/TCPslidewindow.png?imageView2/0/w/800/q/100|imageslim" class="gallery-item" target="_blank" rel="noopener"><img class="tcp-pic" src="http://ovge5llkw.bkt.clouddn.com/images/TCPslidewindow.png?imageView2/0/w/800/q/100|imageslim"></a><hr><h3 id="超时重发"><a href="#超时重发" class="headerlink" title="超时重发"></a>超时重发</h3><pre><code>当发送端送出某一 TCP 数据段后, 将开启一个计时器, 等待接收端的 ACK 回复.如果接收端正确接收到符合次序的数据段,则返回带 ACK 标志的包.发送端收到 ACK 回复后，继续移动窗口,发送接下来的数据段. 如果直到计时完成, 发送端还是没有收到 ACK 回复，那么发送端推断之前发送的数据段已经丢失, 重新发送之前的数据段。这个计时等待的时间叫做重发超时(RTO, retransmission timeout).一般 初始值设置在6秒左右,在 Unix 和 Windows 中,超时都以 0.5s 为单位进行控制,即重发超时为 0.5s 的整数倍.重发后的等待时间会以指数函数增长，但不会无限增长，超过一定次数仍无应答则会强制关闭连接并通知应用程序通信异常终止.</code></pre><p>那么,如何确定RTO呢?<br>　　TCP要求不论处在何种网络环境下都要提供高性能的通信,并且无论网络拥堵情况如何变化, 都必须保持这一特性.<br>为此, 它每次发包都会计算往返时间RTT【称采样RTT(sampling-rtt)】 及其 偏差(RTT抖动,标准差std),RTO的值就比这两者的总和高一点.<br>具体如何计算在不同的平台可能会有不同, 我知道的一种是: sum(srtt[i~i+n])/n + 4 * std</p><blockquote><p>为何要还需考虑偏差?<br>–&gt; 根据网络环境的不同，往返时间可能会发生大幅度的波动, 因为各个数据包的分段可能是经过不同线路到达的.<br>这种情况下,如果我们设置了过小的RTO,那么发送端等待很短的时间就重新发送,而实际上之前发送的片段并没有丢失，只是传输速度比较慢而已. 这样重复发送数据段, 从而浪费网络传输资源.<br>　　换个角度,如果RTO时间设置的过长,那么当数据段已经丢失的情况下,发送端不能及时重发, 则会造成网络资源的闲置.<br>因此, 将偏差值也考虑在内可以尽量避免浪费网络流量,保持TCP特性.</p></blockquote><hr><h3 id="高速重发"><a href="#高速重发" class="headerlink" title="高速重发"></a>高速重发</h3><p>　　在发送端主机连续三次接收到同一个确认应答时,才会对其所对应的数据进行重发<br>　　在窗口较大时, 若1001~2000的 TCP段 还未到达接收端或已丢失,接收端将发送ACK:1001<br>　　由窗口控制机制, 发送端仍会继续发送2001~n的 TCP段, 接收端仍将继续发送ACK:1001,但同时将缓存2001~n的 TCP段.<br>　　高速重发机制在连续3次接收到ACK:1001后才认定需要重发1001~2000的数据段,这比超时重发会高效不少.</p><a href="http://ovge5llkw.bkt.clouddn.com/images/20171108TCPgaosuchongfa.png?imageView2/0/w/800/q/100|imageslim" class="gallery-item" target="_blank" rel="noopener"><img class="tcp-pic" src="http://ovge5llkw.bkt.clouddn.com/images/20171108TCPgaosuchongfa.png?imageView2/0/w/800/q/100|imageslim"></a><hr><h2 id="流机制"><a href="#流机制" class="headerlink" title="流机制"></a>流机制</h2><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><h4 id="流量控制反馈"><a href="#流量控制反馈" class="headerlink" title="流量控制反馈"></a>流量控制反馈</h4><p>TCP 中数据流和流量控制反馈:</p><a href="http://ovge5llkw.bkt.clouddn.com/images/20171108TCPflowcontrol.png?imageView2/0/w/800/q/100|imageslim" class="gallery-item" target="_blank" rel="noopener"><img class="tcp-pic" src="http://ovge5llkw.bkt.clouddn.com/images/20171108TCPflowcontrol.png?imageView2/0/w/800/q/100|imageslim"></a><p>接收端 TCP 反馈控制发送端 TCP, 发送方 TCP 反馈控制 发送端进程.</p><p>接收端主机指示发送端主机对发送数据的量进行控制.</p><a href="http://ovge5llkw.bkt.clouddn.com/images/20171108TCP2.png?imageView2/0/w/800/q/100|imageslim" class="gallery-item" target="_blank" rel="noopener"><img class="tcp-pic" src="http://ovge5llkw.bkt.clouddn.com/images/20171108TCP2.png?imageView2/0/w/800/q/100|imageslim"></a><h4 id="为何需要流控制"><a href="#为何需要流控制" class="headerlink" title="为何需要流控制?"></a>为何需要流控制?</h4><pre><code>发送端若是能发多少、想发多少就发多少, 接收端处理不过来(比如它可能因为收到的是一个毫无关系的数据包而在处理某些问题上花费一些时间)那它可能会在高负荷情况下无法接收任何数据。如此一来，如果接收端将本应该接收的数据丢弃的话，就又会触发重发机制，从而导致网络流量的浪费。流控制机制为接收端提供了一个选择的权利:　它可以通过TCP首部中的一个 Window Size 字段通知发送端自己空余的缓冲区大小(这个值越大，说明网络的吞吐量越高,称为窗口大小).发送端便不会发送超过这一大小限制的数据,且当接收端这个缓冲区面临数据溢出时,窗口大小的值会随之被设置为一个更小的值通知给发送端,从而控制数据发送量.1. 发送窗口的打开、关闭(见「发送窗口」)和收缩由接收端控制.当一个 新ackNo 允许发送窗口关闭时, 发送窗口关闭( |~=&gt; ... ~| ). 当接收方通知的 新rwnd 允许发送方窗口打开时(new ackNo + new rwnd &gt; last ackNo + last rwnd)，发送窗口打开( |~ ... ~|=&gt; ).2. 若是[ new ackNo + new rwnd &gt; last ackNo + last rwnd ] 例(102 + 4 &lt; 100 + 10) 则会发生窗口的收缩( 100|~-&gt;102 ... 106&lt;-~|110 )此时, 它产生了一个问题: 已经被发送的100~110 字节中, 100~102成功清除缓存区 而 106~110则处于窗口之外(可能只是106~110延迟未到达,然接收端却不清楚这部分是否发送),后面发送端还得重复发这部分数据.我们希望能尽量避免这种情况的发生, 一种方法是 :让接收端推迟反馈, 直到在它的窗口中有足够的缓冲区空间(接收端应用程序&apos;拉&apos;) 或者 之前数据确认到达已返回一个受期待的ack 如 106. 总之就是尽量使发送窗口不会发生 右界左移(收缩)3. 某些情况下(如缓冲区已满), 接收端在一段时间内不想接收来自发送端的数据,此时接收端会发送rwnd为0的段, 若按照上方的方法分析, 则此时无法避免地会发生窗口收缩.然鹅~ 实际上, 发送端并不真的收缩窗口大小, 它会停止发送数据直到新的窗口通告到达.即使当窗口因为来自接收方的命令而暂时关闭了, 发送端也总可以发送一个 1 字节数据的数据段, 称为[窗口探测], 用来防止[死锁]-(见↓).</code></pre><blockquote><p>若无窗口探测,为何或何时会死锁？<br>接收端发送 rwnd=0 以使发送端停下来等待新的窗口通告, 过一段时间后, 接收端想要解除对发送端的”封印”, 会发送新的rwnd通告给发送端, 然而, 这个通告若是在传输过程中丢失了… 没错, 此时发送端未接收到新通告故继续等待接收端的指示, 而接收端可不知道这些, 它以为发送端收到了指示, 与上也在等待发送端发送数据! 此时 死锁便产生了.</p></blockquote><hr><h2 id="网络过载与拥塞窗口"><a href="#网络过载与拥塞窗口" class="headerlink" title="网络过载与拥塞窗口"></a>网络过载与拥塞窗口</h2><h3 id="拥塞"><a href="#拥塞" class="headerlink" title="拥塞"></a>拥塞</h3><p>网络中的链路容量和交换结点中的缓存和处理机都有着工作的极限, 当网络的需求超过它们的工作极限时, 就出现了拥塞. </p><p>拥塞控制就是防止过多的数据注入到网络中, 这样可以使网络中的路由器或链路不致过载.</p><h3 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动:"></a>慢启动:</h3><p>在拥塞发生时循序减少主机发送到网络中的 TCP段 数,使得发生拥塞的路由器有足够的时间把队列中积压的 TCP段 处理完毕</p><a href="http://ovge5llkw.bkt.clouddn.com/images/20171108TCP3.png?imageView2/0/w/800/q/100|imageslim" class="gallery-item" target="_blank" rel="noopener"><img class="tcp-pic" src="http://ovge5llkw.bkt.clouddn.com/images/20171108TCP3.png?imageView2/0/w/800/q/100|imageslim"></a><p>发送端维持一个 “拥塞窗口”的窗口大小的值，该值与接收端口共同决定了发送端的发送窗口.<br>当主机发送数据时,在”拥塞窗口”值和接收端通知的窗口大小 间选择一个较小值发送.<br>每收到一个确认应答就增发一个段(发送段数指数增长,这样的激增可能导致网络拥塞,故引入了慢启动阀值)<br>最后会达到一个提前预设的 “慢启动阀值(slow-start threshold)”,此时:</p><pre><code>cwnd &lt; ssthresh， 继续使用慢启动算法;cwnd &gt; ssthresh，停止使用慢启动算法，改用拥塞避免算法;cwnd = ssthresh，既可以使用慢开始算法, 也可以使用拥塞避免算法.[cwnd为窗口大小,初始为1]</code></pre><p>所谓拥塞避免算法就是:每经过一个往返时间 RTT 就把发送方的拥塞窗口+1,即让拥塞窗口缓慢地增大,按照线性规律增长.<br>当出现网络拥塞,比如丢包时,将慢启动阀值重设为原先的值,然后将cwnd设为1, 执行慢启动算法(较低的起点,指数级增长)</p><h3 id="快重传-快恢复"><a href="#快重传-快恢复" class="headerlink" title="快重传+快恢复:"></a>快重传+快恢复:</h3><p>减少因为拥塞导致的数据包丢失带来的重传时间, 从而避免传递无用的数据到网络</p><a href="http://ovge5llkw.bkt.clouddn.com/images/20171108TCP4.jpg?imageView2/0/w/800/q/100|imageslim" class="gallery-item" target="_blank" rel="noopener"><img class="tcp-pic" src="http://ovge5llkw.bkt.clouddn.com/images/20171108TCP4.jpg?imageView2/0/w/800/q/100|imageslim"></a><p>接收方建立这样的机制, 如果一个包丢失, 则对后续的包继续发送针对该包的重传请求;<br>一旦发送方接收到 3 个一样的确认, 就知道该包之后出现了错误(网络轻微阻塞), 立刻重传该包:<br>此时发送方开始执行 “快恢复” 算法:</p><pre><code>慢启动阀值减半;cwnd设为慢启动阀值减半后的数值;执行拥塞避免算法(高起点,线性增长).</code></pre><blockquote><p>新版本的TCP中, 如果 发生超时, TCP进入慢启动状态(如果它已经处于此状态,则开始新的一轮); 如果三<br>次重复 ACK 到达, 则 TCP 进入快速恢复状态, 并且 有更多的重复 ACK 到达, 它仍保持这种状态.</p></blockquote><hr><h2 id="提高网络利用率"><a href="#提高网络利用率" class="headerlink" title="提高网络利用率"></a>提高网络利用率</h2><h3 id="Nagle算法"><a href="#Nagle算法" class="headerlink" title="Nagle算法"></a>Nagle算法</h3><p>　Nagle算法即 在发送端还有需要发送的数据 然而数据量较小的情况下 延迟发送,等待较合适的数据量 (发送端糊涂窗口综合症, 可能使得发送端应用程序刚推送几个字节的数据 TCP就创建段以发送这些数据,网络利用率低下).<br>若以下两条件都不满足，则执行 Nagle 算法(有开启的话):</p><ul><li>已发送的数据都已经收到 ACK</li><li>可以发送达到 MSS 的数据时</li></ul><p>Nagle 算法能提高网络的利用率但可能会造成某种程度的延迟,故某些系统(如窗口系统)中可能会关闭对他的支持.</p><h3 id="Clark算法与延迟确认"><a href="#Clark算法与延迟确认" class="headerlink" title="Clark算法与延迟确认"></a>Clark算法与延迟确认</h3><p>　为解决 消耗数据速率 远低于 数据到达速率 而产生的接收端糊涂窗口综合征(接收端应用程序龟速’拉数据’,缓冲区每次都趋满状态,返回一个很小的窗口), Clark 提出, 数据一到达就发送确认(与延迟应答的区别), 但是声明一个大小为 0 的窗口, 直到有足够的空间容纳大段，或者至少半个接收缓冲区是空的才正常反馈 rwnd值.</p><p>＝另一种方法为延迟发送确认 , 见下一部分 ↓</p><h3 id="延迟应答"><a href="#延迟应答" class="headerlink" title="延迟应答"></a>延迟应答</h3><p>　延迟应答即在收到数据之后不立即返回 ACK ,而是延迟一段时间再返回：</p><ul><li>在未收到两倍最大段长的数据（不同操作系统可能不同）前不返回ACK</li><li>其他情况,最大延迟0.5s返回 ACK </li><li>延迟的时间也不宜过长,不然可能导致发送端重发</li></ul><h3 id="捎带应答"><a href="#捎带应答" class="headerlink" title="捎带应答"></a>捎带应答</h3><p>　捎带应答即在同一个 TCP包中即发送数据又发送 ACK ,以使得收发的数据量减少的一种机制.</p><ul><li>到 TCP层 将接收的数据 送至应用层处理后生成返回数据后 再进行发送请求 为止,必须等待 ACK 的发送</li><li>若接收数据后立即返回 ACK ,就无法实现捎带应答</li><li>即 延迟应答是实现捎带应答的基础.</li></ul><hr><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot;&gt;&lt;div class=&quot;.article-gallery&quot; &lt;blockquote=&quot;&quot;&gt;
&lt;blockquote&gt;&lt;p&gt;为有源头活水来…&lt;/p&gt;
&lt;footer&gt;&lt;strong&gt;[Zhu Xi]&lt;/strong&gt;&lt;/footer&gt;&lt;/blockquote&gt;

&lt;blockquote&gt;
&lt;p&gt;2017-11-19 2rd&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;BEGIN&quot;&gt;&lt;a href=&quot;#BEGIN&quot; class=&quot;headerlink&quot; title=&quot;BEGIN&quot;&gt;&lt;/a&gt;BEGIN&lt;/h2&gt;&lt;hr&gt;
&lt;h2 id=&quot;可靠传输基础&quot;&gt;&lt;a href=&quot;#可靠传输基础&quot; class=&quot;headerlink&quot; title=&quot;可靠传输基础&quot;&gt;&lt;/a&gt;可靠传输基础&lt;/h2&gt;&lt;p&gt; 序列号( SYN )与确认应答号( ACK ): &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 发送端发送某一 TCP 段, 需要清楚接收端是否成功接收这个 TCP段 ,  才能确定下一步是重新发送还是继续发送下一 TCP段.
2. 接收端也需要清楚自己接收的是哪个 TCP段 , 才能决定下一步的工作(重复出错丢弃, 按需请求重发).
3. TCP段 乱序到达, 需要知道如何正确排序.
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://www.cpphonor.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="TCP/IP" scheme="http://www.cpphonor.cn/tags/TCP-IP/"/>
    
      <category term="深入理解TCP系列" scheme="http://www.cpphonor.cn/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>深入理解TCP-连接建立与断开</title>
    <link href="http://www.cpphonor.cn/2017/10/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP-%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E4%B8%8E%E6%96%AD%E5%BC%80/"/>
    <id>http://www.cpphonor.cn/2017/10/28/深入理解TCP-连接建立与断开/</id>
    <published>2017-10-28T11:44:49.000Z</published>
    <updated>2017-11-30T13:54:46.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <blockquote=""><blockquote><p>只有体验过极度不幸的人<br>才能感受到极度的幸福<br>我们只有感受过死亡接近<br>才能欣赏活着的快乐</p><footer><strong>[Alexandre Dumas]</strong></footer></blockquote><blockquote><p>2017-11-19 2rd</p></blockquote><h2 id="BEGIN"><a href="#BEGIN" class="headerlink" title="BEGIN"></a>BEGIN</h2><hr><h2 id="为何需要TCP"><a href="#为何需要TCP" class="headerlink" title="为何需要TCP :"></a>为何需要TCP :</h2><p>作为传输层的一类协议，为OSI 5~7层的某些缺陷提供解决的策略 ( 当然并非尽善尽美 )<br>比如,IP协议簇是不保证传输和连接的可靠性的. 而 TCP则尝试解决相应的问题</p><a id="more"></a><p>它需要做的事大体如下:</p><pre><code>1．发现并丢弃被破坏的分组2．记录丢失和丢弃的分组并重传它们3．识别重复分组并丢弃它们4．缓冲失序分组直到丢失的分组到达5. 尽量高效而优雅地做1~4</code></pre><p>TCP 是一种字节流传输协议, 它将多个字节组合成一个分组.<br>TCP 中的分组称为 段(segment), 段的格式为:</p><pre><code>&lt;= | 首部（20 ~ 60 byte） + 数据 | &lt;=   // [60 : 20 + Options字段长]</code></pre><hr><h2 id="TCP首部"><a href="#TCP首部" class="headerlink" title="TCP首部 :"></a>TCP首部 :</h2><hr><a href="http://ovge5llkw.bkt.clouddn.com/images/20171028TCP1.png?imageView2/0/w/800/q/100|imageslim" class="gallery-item" target="_blank" rel="noopener"><img class="tcp-pic" src="http://ovge5llkw.bkt.clouddn.com/images/20171028TCP1.png?imageView2/0/w/800/q/100|imageslim"></a><pre><code>1.Sequence Number (序列号/字节序号) [注:需区别于 段中的序号]TCP 是 一种字节流传输协议, 为了确保连通性, 对要发送的 `每一个字节` 都进行编号.序列号告诉接收端,在这个序列中哪一个字节是该段的第一个字节.其初始值是在建立连接时随机生成的,两端各自生成自己的初始SYN, 由 SYN/SYN+ACK 包进行传递给接收端.若m为序列号字段长度,则   0 &lt; Seq = x % (2^m) &lt; (2^m)-1.  [TCP: m=32]当 TCP 接收来自进程的一些数据字节时, TCP 将它们存储在发送缓冲区中并给它们编号.字节流可能被分段,每个段都会有一个段序号字段:Seq确定后, TCP 对发送的每一个段分配一个段序号.序号指出该段的第一个字节的序号.第一段的序号是初始序号(ISN), 后续 TCP段 的序号是之前段的序号加之前段携带的字节数. 某些控制段不携带数据但也会占有一个序号 如 SYN.若一个 TCP段 即携带控制信息又携带数据(如捎带应答)时, 使用一个序号.</code></pre><div style="text-align:center"><br><a href="http://ovge5llkw.bkt.clouddn.com/images/TCPcachetosegment.png?imageView2/0/w/800/q/100|imageslim" class="gallery-item" target="_blank" rel="noopener"><img class="tcp-pic" src="http://ovge5llkw.bkt.clouddn.com/images/TCPcachetosegment.png?imageView2/0/w/800/q/100|imageslim"></a><br><span>(缓冲区中 由字节生成段)</span><br></div><pre><code>2.Ack Number (确认应答号)：[也是指的字节序号]　期望收到的下一部分数据第一字节的序列号, 接收端返回的ACK若为 6001 ,则表示  希望发送端下一次发送6001~（6001+数据段长）的数据，也表明从起始到6000的数据都已经成功接收.3.Header Length: 　有时也称为数据偏移，表示TCP首部的长度，单位为4个字节，若其值为5，则表示TCP首部长为5×4=20字节4.CWR(拥塞窗口减小)与ECE(ECN-Echo):   ECN（显式拥塞通知），IP层显式拥塞通知机制：（数据包的IPheader中若ECN为01或10时，表示該包发送端支持ECN机制）　当发生网络拥塞时，它将在发送的包的IP首部中记录路由器是否发生拥塞(设置ECN字段为11)；　接收端发现了IP首部 ECN 为11，返回设置ECE标志的SYN-ACK/ACK包，表示发生了网络拥塞，希望发送端减小发送窗口;　当发送端接收到該包时,减小发送窗口并发送设置有CWR新的数据包,告诉接收端已经减小了发送窗口;　接收端收到设置有CWR的包后停止在接下来的ACK包中设置ECE。　（拥塞检查在网络层进行，而拥塞通知在传输层进行）5.ACK与URG:　ACK:是否启用确认应答字段(Ack Number)，一旦连接建立，其值固定为1　URG:是否启用紧急指针(Urgent Pointer)6.SYN（Synchronize Flag）与 FIN（ Finish Flag）:　建立连接时，SYN为1，表达希望建立连接，并且设置序列号的初始值。希望建立连接的双方交换SYN包并获得对方确认应答后建立连接　希望断开连接时， FIN设为1，通信双方交换 FIN 包，均获得对方确认应答后断开连接  就如同:     A: 我想断开连接 发送 FIN （进入  FIN_WAIT_1 状态, 等待接收确认应答，不发送任何信息）    B: 收到了你的请求 发送ACK     ( A收到后进入  FIN_WAIT_2，等待接收 FIN )    ( B准备断开.....缓冲区内的数据都已经成功发送而被自动删除... )    B: 断开吧，发送 FIN    A: (接收到 FIN) 知道了，你断开吧  发送ACK       [但是A生怕B没收到ACK, 进入到TIME_WAIT,若再收到B的请求则重发ACK, 等待2MSL未收到新请求，则A关闭连接]    ( B收到ACK后 断开了连接 )    ------详细状态转化见下图(tcp状态转化)7.Window Size(窗口大小/接收窗口)：　发送端无需等待确认应答而可以继续发送的数据的最大值，详见(TCP-传输控制)，值为0时，发送窗口探测连接最新的窗口大小.　此值由接收端主导, 发送端服从.　窗口大小与RTT（往返时间）可决定一个TCP通信的最大吞吐量:    T=Wsize/RTT    吞吐量可通过增加连接数来提升，但是增长并非无限制，此处不作深究8.TCP Checksum(校验和)：　对于路由器内存故障或者程序漏洞导致的数据破坏进行检查，可判断协议首部和数据是否被破坏9.Urgent Pointer:　其指向的位置为紧急数据的末尾在报文段中的位置, 即数据首位到UrgentPointer指向的位置为止为紧急数据  例 若某 TCP段 的段序号为 1001, UP值为100, 则TCP将 1001~1201 的数据流 放置到段的起始部分  但 此字段仅告知接收端, 1001~1201为紧急数据, 具体的处理交由接收端应用程序.10.PSH (推送位):　一般情况下,发送方的 TCP 使用缓冲区存储来自发送方应用程序的数据流;  接收端的 TCP 在数据到达时将数据进行缓存,并当应用程序准备就绪时或当接收端 TCP 认为方便时将这些数据传递给应用程序;  这些机制使得传输调控更为灵活. 然而有时候应用程序并不希望有这样的灵活：  某些应用程序希望 TCP 将自己的请求立即发出并希望能立即得到接收端的响应(不允许数据的延迟),此时  发送端的应用程序可请求推送操作 并设置 推送位PSH.  这就表示发送端的 TCP 不必等待窗口被填满, 每创建一个 TCP 段就立即将其发送给接收端  而接收端检测到PSH便知道此数据应立即传递给接收端的应用程序.11.Options　此字段用于提高TCP的传输性能（常见的有窗口扩大，选择性确认应答[SACK]，时间戳字段等选项）</code></pre><hr><h2 id="TCP连接的建立与关闭"><a href="#TCP连接的建立与关闭" class="headerlink" title="TCP连接的建立与关闭:"></a>TCP连接的建立与关闭:</h2><hr><h3 id="TCP连接的建立-三次握手："><a href="#TCP连接的建立-三次握手：" class="headerlink" title="TCP连接的建立-三次握手："></a>TCP连接的建立-三次握手：</h3><pre><code>1. Client发送位码为 SYN = 1（SYN 标志位置位）,随机产生初始序列号 Seq = x 的数据包到 Server. Server 由 SYN = 1知道，Client要求建立连接.2. Server 收到请求后要确认连接信息，向Client 发送确认号Ack Number = （Client的Seq +1，x+1），SYN = 1，ACK = 1（SYN，ACK 标志位置位）   随机产生的序列号 Seq = y 的数据包.3. Client收到后检查 AckNumber 是否正确，即是否为第一次发送的 Seq +1（x+1），以及位码 ACK 是否为1.   若正确, Client会再发送 AckNumber = （Server的Seq+1，y+1）,ACK = 1, 以及序号Seq为Server确认号x 的确认包.   Server 收到后确认之前发送的 Seq（y+1） 值与 ACK= 1 （ACK置位）则连接建立成功.</code></pre><h3 id="TCP连接到关闭-四次挥手："><a href="#TCP连接到关闭-四次挥手：" class="headerlink" title="TCP连接到关闭-四次挥手："></a>TCP连接到关闭-四次挥手：</h3><p>　　由于TCP连接是全双工的，因此每个方向都必须单独进行关闭，也就是发送方和接收方都需要 Fin和Ack。<br>这个原则是当一方完成它的数据发送任务后就能发送一个 FIN来终止这个方向的连接，收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个 FIN后仍能发送数据。<br>　　首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</p><pre><code>1. Client发送一个 FIN Seq = M（ FIN置位，序号为M）包，用来关闭Client到Server的数据传送.2. Server收到这个 FIN，它发回一个ACK，确认序号Ack 为收到的序号M+1.3. Server关闭与Client的连接，发送一个 FIN Seq = N 给Client.4. Client发回ACK 报文确认，确认序号Ack 为收到的序号N+1.</code></pre><blockquote><p>全双工:数据可以在同一时间双向流动, 每一方向 TCP 都有发送和接收缓冲区, 都能发送和接收段.</p></blockquote><h3 id="TCP状态转化：（图片来源于网络）"><a href="#TCP状态转化：（图片来源于网络）" class="headerlink" title="TCP状态转化：（图片来源于网络）"></a>TCP状态转化：（图片来源于网络）</h3><div style="text-align: center;margin-top: -25px;"><br><div style="width: 420px;margin: 5px 0px;float: left;"><br>    <a href="http://ovge5llkw.bkt.clouddn.com/images/20171028TCP2.png?imageView2/0/q/100|imageslim" class="gallery-item" target="_blank" rel="noopener"><img src="http://ovge5llkw.bkt.clouddn.com/images/20171028TCP2.png?imageView2/0/q/100|imageslim"></a><br>    <b>图一</b><br></div><br><div style="width: 440px;margin-top:-25px;  float: right;"><br>    <a href="http://ovge5llkw.bkt.clouddn.com/images/20171028TCP3.png?imageView2/0/q/100|imageslim" class="gallery-item" target="_blank" rel="noopener"><img src="http://ovge5llkw.bkt.clouddn.com/images/20171028TCP3.png?imageView2/0/q/100|imageslim"></a><br>    <b>图二</b><br></div><br></div><p><div style="clear: both;"></div></p><blockquote><p>接下来看图说话：（看不清楚可以点击图片全屏预览）</p></blockquote><p>首先来看图二的上半部分，表示的是三次握手的状态转移</p><pre><code>1. 图二中，我们假设服务器端从CLOSED状态开始，表明此时服务器端连接关闭后的状态(这里只是为了表示&quot;连接关闭&quot;这一状态，实际上TCP无此状态)2. 当服务器端被动打开（比如一个 socket 被打开）以等待客户端的连接时，进入LISTEN状态，此状态的服务器监听客户端的连接请求.  [提供服务就得打开端口，TCP状态的变化实质是端口的状态变化](请结合图一看，以较容易地理解其过程)3. 客户端主动发起连接(比如调用了connect() 函数)，客户端发送SYN包给服务端，进入SYN_SENT状态, 等待服务端进行确认. 4. 服务端接收到客户端的连接请求(SYN) ，进入 SYN_RCVD 状态，同时返回 SYN+ACK 包给客户端 (图二 虚线 LISTEN --&gt; SYN_RCVD )5. 客户端接收到服务端的响应(SYN+ACK) , 发送一个ACK确认应答后进入ESTABLESHED状态( 表明处于连接状态 )6. 服务端接收到 ACK包后 也进入到 ESTABLISHED状态三次握手结束，客户端和服务端均进入到ESTABLISHED状态，客户端与服务端开始促膝长谈....注：【图二中有一个状态转移是:客户端主动打开, 发送SYN进入SYN_SENT状态时收到服务端的连接请求(即收到SYN包)则此时 客户端也会转入SYN_RCVD状态,直至收到RET或自己发送 FIN】</code></pre><p>然后再看下半部分，四次挥手过程：</p><pre><code>1. 以客户端主动关闭为例，客户端发送 FIN 进入 FIN_WAIT_1 状态，等待服务端的确认。  (若此时收到服务端的关闭请求 FIN 则直接进入到 CLOSING 同时发送 ACK,直至收到服务端的确认应答，进入TIME_WAIT.   这是双方同时提出关闭连接的情况)2. 服务端接收到客户端关闭连接的请求( FIN ),发送确认应答 ACK 并进入 CLOSE_WAIT 状态,   客户端接收到此 ACK 则进入到 FIN_WAIT_2 状态，等待服务端的关闭请求3. 然后发送 FIN表示欲关闭连接，进入 LAST_ACK 状态4. 客户端收到服务端关闭请求 FIN，发送确认应答，并进入 TIME_WAIT,等待 2MSL 以确认服务端成功接收到了 ACK,    ①.未再次收到服务端的 FIN请求则表示连接顺利关闭，②.收到则重发。   (MSL 是IP数据报能够在因特网中存活的最长时间)5. 服务端收到客户端的确认应答 ACK, 关闭连接。注：【  一个常见的问题是，为什么要有 TIME_WAIT 状态？为什么等待2MSL？  让我们来看看没有 TIME_WAIT 的情况：  1.客户端从 FIN_WAIT_2 状态直接转入了 CLOSED, 此时 若过程（4）中客户端返回的 ACK 丢失，  则当服务器再次发送请求 FIN, 会得到客户端的 RST 响应，服务端会将其解释为一个错误，从而服务端不能关闭连接  2.若原先连接双方仍有部分数据包由于线路的网络延迟或拥塞，残存于网络中，此时，  一个来自与“之前连接的一方” 同一IP地址和端口的新连接 刚刚建立，残存的数据包可能会被这个连接的一方接受  等待的时间为 2MSL, 是为了保证两个方向上的数据包都不能残存。】</code></pre><p>半关闭连接终止转换图:<br><a href="http://ovge5llkw.bkt.clouddn.com/images/20171028TCPhalfclose.png?imageView2/0/w/800/q/100|imageslim" class="gallery-item" target="_blank" rel="noopener"><img class="tcp-pic" src="http://ovge5llkw.bkt.clouddn.com/images/20171028TCPhalfclose.png?imageView2/0/w/800/q/100|imageslim"></a></p><blockquote><p>一端请求停止发送数据后, 还可以继续接收数据.</p></blockquote><hr><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot;&gt;&lt;div class=&quot;.article-gallery&quot; &lt;blockquote=&quot;&quot;&gt;
&lt;blockquote&gt;&lt;p&gt;只有体验过极度不幸的人&lt;br&gt;才能感受到极度的幸福&lt;br&gt;我们只有感受过死亡接近&lt;br&gt;才能欣赏活着的快乐&lt;/p&gt;
&lt;footer&gt;&lt;strong&gt;[Alexandre Dumas]&lt;/strong&gt;&lt;/footer&gt;&lt;/blockquote&gt;

&lt;blockquote&gt;
&lt;p&gt;2017-11-19 2rd&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;BEGIN&quot;&gt;&lt;a href=&quot;#BEGIN&quot; class=&quot;headerlink&quot; title=&quot;BEGIN&quot;&gt;&lt;/a&gt;BEGIN&lt;/h2&gt;&lt;hr&gt;
&lt;h2 id=&quot;为何需要TCP&quot;&gt;&lt;a href=&quot;#为何需要TCP&quot; class=&quot;headerlink&quot; title=&quot;为何需要TCP :&quot;&gt;&lt;/a&gt;为何需要TCP :&lt;/h2&gt;&lt;p&gt;作为传输层的一类协议，为OSI 5~7层的某些缺陷提供解决的策略 ( 当然并非尽善尽美 )&lt;br&gt;比如,IP协议簇是不保证传输和连接的可靠性的. 而 TCP则尝试解决相应的问题&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://www.cpphonor.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="TCP/IP" scheme="http://www.cpphonor.cn/tags/TCP-IP/"/>
    
      <category term="深入理解TCP系列" scheme="http://www.cpphonor.cn/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>JS必知必会:类型与语法</title>
    <link href="http://www.cpphonor.cn/2017/09/24/JavaScript-YNTK-1/"/>
    <id>http://www.cpphonor.cn/2017/09/24/JavaScript-YNTK-1/</id>
    <published>2017-09-24T15:08:44.000Z</published>
    <updated>2017-09-24T15:45:12.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <blockquote=""><blockquote><p>我们可以断言,<br>缺乏激情,<br>任何伟大的事业都不可能完成</p><footer><strong>[Georg·Wilhelm·Friedrich·Hegel]</strong></footer></blockquote><hr><h1 id="一-Boolean真值假值："><a href="#一-Boolean真值假值：" class="headerlink" title="一.Boolean真值假值："></a>一.Boolean真值假值：</h1><p>假值和所有可强转为假值的只有：</p><pre><code>* false* null，undefined，NaN* +0，-0* &quot;&quot;(空字符串)</code></pre><p>其他的都为真值！！</p><a id="more"></a><hr><h1 id="二-字位层面的强转：”-”"><a href="#二-字位层面的强转：”-”" class="headerlink" title="二.字位层面的强转：”~”"></a>二.字位层面的强转：”~”</h1><pre><code>&quot;~&quot;操作相当于取操作数的补码：~x=-(x+1)它首先将值转换为32位数字,再执行“非”操作( 按位取反码 )可知，仅在对-1进行~操作时返回0，这使得我们可以隐藏一些方法底层判断实现的细节：如indexOf( )  当 匹配不到相应的子串时 我们经常使用 a.indexOf(&quot;str&quot;)!=-1来判断是否成功匹配然而，这暴露了底层的实现，即，返回值为-1时 匹配失败现在，我们可使用 ~a.indexOf(&quot;str&quot;)  来实现，返回-1，结果为0,即为false, 以此隐藏底层的实现细节。</code></pre><hr><h1 id="三-宽松相等与严格相等：”-”-and-“-”"><a href="#三-宽松相等与严格相等：”-”-and-“-”" class="headerlink" title="三.宽松相等与严格相等：”==”  and  “===”:"></a>三.宽松相等与严格相等：”==”  and  “===”:</h1><h2 id="1-误区-’-’只需比较值，而’-’比较值和类型"><a href="#1-误区-’-’只需比较值，而’-’比较值和类型" class="headerlink" title="1.误区:’==’只需比较值，而’===’比较值和类型"></a>1.误区:’==’只需比较值，而’===’比较值和类型</h2><pre><code>* 正确的理解应该是，&quot;==&quot;允许进行强制类型转化后比较* 两者都需要检测值的类型* 当类型相同时处理方式相同* 不同的是，在值的类型不同时，两者的处理方式，一个进行强转，一个则不允许</code></pre><h2 id="2-’-’的强转规则："><a href="#2-’-’的强转规则：" class="headerlink" title="2.’==’的强转规则："></a>2.’==’的强转规则：</h2><pre><code>1.当 字符串与数字进行 比较时, 先将字符串转为数字:x==y  =&gt;  ToNumber(x) == y2.当 布尔值与数字进行 比较时, 先将布尔值转化为数字:x=false, y=0   x==y  =&gt;  ToNumber(x)==y   =&gt;   0==y  =&gt;truex=false, y=&quot;0&quot;  x==y   =&gt;   0==ToNumber(y)   =&gt;  0==0  =&gt; true3.当 对象( 对象,数组,函数 ) 与 非对象 比较时, 先调用 unwraped（拆封） 方法 toPrimitive ( 如 toString() valueOf() )x=[&quot;1&quot;], y=true  x==y  =&gt;  ToPrimitive(x)==y =&gt;  &quot;1&quot; == true  =&gt; &quot;1&quot;==1 =&gt;  1==1  =&gt;true4.null and undefined: null与undefined可相互隐式强转null == undefined // truenull == false // falsenull == 0 //falsenull == &quot;&quot; //falseif (a==null) 相当于 if (a===null || a===undefined) </code></pre><h2 id="3-极端情况"><a href="#3-极端情况" class="headerlink" title="3.极端情况:"></a>3.极端情况:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[]==![]  //true  ![] -&gt; false  =&gt;  [] ==false  =&gt; &quot;&quot; ==false  =&gt; Number(&quot;&quot;)==false =&gt; 0==0</span><br></pre></td></tr></table></figure><p>　假值与与真值比较由于隐式强转的存在，可能返回true<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Boolean([])-&gt;true  but  []==false  =&gt;true</span><br><span class="line">&quot;0&quot; is true value but &quot;0&quot;==false  =&gt;true</span><br><span class="line"></span><br><span class="line">0==&quot;\n&quot;  //true</span><br><span class="line">&quot;&quot;=[null]  /true  [null].toString() =&gt; &quot;&quot;</span><br><span class="line">2==[2]  //true</span><br></pre></td></tr></table></figure></p><p>　同类型对象间的比较，不涉及类型转化,直接比较的是对象的引用:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[]==[]  &#123;&#125;==&#123;&#125;  [[]]==[[]]  [0]==[0]  [1]==[1]   //false!!!</span><br></pre></td></tr></table></figure></p><h2 id="4-经验之谈："><a href="#4-经验之谈：" class="headerlink" title="4.经验之谈："></a>4.经验之谈：</h2><pre><code>* 若两边的值中有true or  false ，千万别使用 &quot;==&quot;* 若两边的值中有[ ] 、&quot;&quot; 或 0 ，尽量不要使用 &quot;==&quot;</code></pre><hr><h1 id="四-抽象关系比较-“-lt-”、”-lt-“、”-gt-”"><a href="#四-抽象关系比较-“-lt-”、”-lt-“、”-gt-”" class="headerlink" title="四.抽象关系比较 “&lt;”、”&lt;=  “、”&gt;”"></a>四.抽象关系比较 “&lt;”、”&lt;=  “、”&gt;”</h1><blockquote><p>需注意的是隐式的强制类型转化</p></blockquote><p>1.先对两边分别调用ToPrimitive方法，若拆封的结果出现非字符串值，则通过ToNumber方法，显式转化为数值进行比较<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a=[42],b=[&quot;43&quot;]   a&lt;b; //true</span><br></pre></td></tr></table></figure></p><p>2.若双方都为字符串，则按照字母顺序来进行比较:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a=[&quot;42&quot;],  b=[&quot;043&quot;]  a&lt;b ;//false  &quot;4&quot;&gt;&quot;0&quot;</span><br><span class="line">var a=[4,2] ,  b=[0,4,3]  a&lt;b  =&gt;  &quot;4,2&quot; &lt; &quot;0,4,3&quot;  =&gt; &quot;4&quot; &lt; &quot;0&quot;  =&gt;false</span><br><span class="line"></span><br><span class="line">特：var a=&#123;c:42&#125; , b=&#123;c:43&#125;  a&lt;b  =&gt;false  //两者都转化为 &quot;[obeject Object]&quot;</span><br></pre></td></tr></table></figure></p><p>3.”&lt;=” 的含义为”不大于”：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a&lt;=b  将被转化为 !(a&gt;b) =&gt; !(b&lt;a) 实现</span><br><span class="line">因此出现了 ：a=&#123;c:42&#125;  b=&#123;c:43&#125;</span><br><span class="line">a&lt;b =&gt;false   a==b =&gt; false   but: a&lt;=b =&gt;true</span><br><span class="line">因为 b&lt;a -&gt;false  !(b&lt;a) -&gt;true</span><br></pre></td></tr></table></figure></p><hr><h1 id="五-上下文规则：代码块与标签"><a href="#五-上下文规则：代码块与标签" class="headerlink" title="五.上下文规则：代码块与标签"></a>五.上下文规则：代码块与标签</h1><h2 id="1-标签"><a href="#1-标签" class="headerlink" title="1.标签"></a>1.标签</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    //declare or function or expression</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　代码块可被正确解析,同c++,这很好理解<br>　然而<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    foo:funcName()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　也可以正确解析,是因为JavaScript中的标签语法,foo如同一个标记一般，对应funcName()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    foo:for(..;..;..)&#123;</span><br><span class="line">            for(..;..;..)&#123;</span><br><span class="line">                if(flag)</span><br><span class="line">                    continue foo;//跳到下一轮foo的循环</span><br><span class="line">                if(flag2)</span><br><span class="line">                    break foo;//跳出foo的循环</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    //....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　标签不允许为字符串,{“a”:”value”} //error</p><pre><code>注:JSON数据的属性名则必须使用双引号,JSON是JS语法的一个子集,但本身并非合法的JS语法,故不能直接当作代码执行(会被当成带&quot;非法标签&quot;的语句块),需要通过JSON-P转化为合法的JS语法* JSON-P将JSON数据封装为函数调用,如foo({&quot;a&quot;:&quot;value&quot;};</code></pre><h2 id="2-代码块"><a href="#2-代码块" class="headerlink" title="2.代码块"></a>2.代码块</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[]+&#123;&#125; //&quot;[object Obejct]&quot;</span><br><span class="line">&#123;&#125;+[] //0</span><br><span class="line">两者的结果不同主要原因在于语句解析的不同:</span><br><span class="line">&#123;&#125; + [] 被解析为 &#123;&#125;代码块 和 +[]  =&gt;   do &#123;&#125; then do +[] 结果为 0</span><br></pre></td></tr></table></figure><h2 id="3-对象解构"><a href="#3-对象解构" class="headerlink" title="3.对象解构"></a>3.对象解构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function getD()&#123;return &#123;a:1,b:&quot;str&quot;&#125;&#125;</span><br><span class="line">var &#123;b,a&#125;=getD();  //a-&gt;1  b-&gt;&quot;str&quot;</span><br><span class="line">//&#123;b,a&#125;是 &#123;b:b,a:a&#125;的简写版本</span><br><span class="line"></span><br><span class="line">function foo(&#123;a,b&#125;)&#123;</span><br><span class="line">    console.log(a,b); // 可直接访问参数对象的属性</span><br><span class="line">&#125;</span><br><span class="line">foo(&#123;b:&quot;hello&quot;,a:&quot;world&quot;&#125;) //hello world</span><br></pre></td></tr></table></figure><hr><h1 id="六-活用switch…-case"><a href="#六-活用switch…-case" class="headerlink" title="六.活用switch….case"></a>六.活用switch….case</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">switch(a)&#123;</span><br><span class="line">    case 1: ...;break;</span><br><span class="line">    case 2: ...;break;</span><br><span class="line">    default: ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　a与case n 之间是严格相等关系,即 a===n时才会执行相应代码,这似乎不够灵活,然而可以换个角度思考：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var b=&quot;2&quot;;</span><br><span class="line">swtich(true)&#123;</span><br><span class="line">    case b==1: ...;break;</span><br><span class="line">    case b==2: ...;break;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　此时,true 与 “b==2”之间仍是严格相等比较 , 然而却灵活地使用了宽松相等”==”,允许了强转</p><hr><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p>　　沉迷 JavaScript 不能自拔,日渐消瘦…</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot;&gt;&lt;div class=&quot;.article-gallery&quot; &lt;blockquote=&quot;&quot;&gt;
&lt;blockquote&gt;&lt;p&gt;我们可以断言,&lt;br&gt;缺乏激情,&lt;br&gt;任何伟大的事业都不可能完成&lt;/p&gt;
&lt;footer&gt;&lt;strong&gt;[Georg·Wilhelm·Friedrich·Hegel]&lt;/strong&gt;&lt;/footer&gt;&lt;/blockquote&gt;

&lt;hr&gt;
&lt;h1 id=&quot;一-Boolean真值假值：&quot;&gt;&lt;a href=&quot;#一-Boolean真值假值：&quot; class=&quot;headerlink&quot; title=&quot;一.Boolean真值假值：&quot;&gt;&lt;/a&gt;一.Boolean真值假值：&lt;/h1&gt;&lt;p&gt;假值和所有可强转为假值的只有：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;* false
* null，undefined，NaN
* +0，-0
* &amp;quot;&amp;quot;(空字符串)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其他的都为真值！！&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript基础" scheme="http://www.cpphonor.cn/categories/JavaScript%E5%9F%BA%E7%A1%80/"/>
    
      <category term="YouDon&#39;tKnowJS" scheme="http://www.cpphonor.cn/categories/JavaScript%E5%9F%BA%E7%A1%80/YouDon-tKnowJS/"/>
    
    
      <category term="JavaScript" scheme="http://www.cpphonor.cn/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Footprint</title>
    <link href="http://www.cpphonor.cn/2017/09/11/footprint-17-09-11/"/>
    <id>http://www.cpphonor.cn/2017/09/11/footprint-17-09-11/</id>
    <published>2017-09-11T14:41:46.000Z</published>
    <updated>2017-11-30T14:22:16.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <blockquote=""><h2 id="Beginning"><a href="#Beginning" class="headerlink" title="Beginning"></a>Beginning</h2><blockquote><p>独立的思想使你避免成为行尸走肉,别轻易地让他人影响你的想法 …</p><footer><strong>[Mark Tovin]</strong></footer></blockquote><hr><hr><blockquote><p>2017 年 9 月 11 日</p></blockquote><p>　　新的一周，杭城已然褪去了夏天的炎热，你很难忍受多变的气温与空气的湿度。时而酷热难耐，时而又冷风淅淅…<br><a id="more"></a></p><p>　　近日填坑一览:</p><blockquote><ul><li>使用cloudflare使个人博客支持https</li><li>Angular RxJS的理解(见”Rx (Reactive Extensions)”)</li><li>将网易云音乐的播放栏的效果集成到了Re-Music中[当然后期需继续解耦]</li></ul></blockquote><hr><h2 id="Use-Cloudflare"><a href="#Use-Cloudflare" class="headerlink" title="Use Cloudflare"></a>Use Cloudflare</h2><hr><h3 id="注册Cloudflare账号"><a href="#注册Cloudflare账号" class="headerlink" title="注册Cloudflare账号"></a>注册Cloudflare账号</h3><pre><code>//first...second......... then 注册成功</code></pre><h3 id="添加两条A记录"><a href="#添加两条A记录" class="headerlink" title="添加两条A记录"></a>添加两条A记录</h3><pre><code>本人使用的域名是通过腾讯云的租的，故前往腾讯云控制台添加points-to:192.30.252.153ponits-to:192.30.252.154</code></pre><h3 id="Cloudflare-Nameservers"><a href="#Cloudflare-Nameservers" class="headerlink" title="Cloudflare Nameservers"></a>Cloudflare Nameservers</h3><pre><code>可在个人实例&gt;DNS分栏&gt;Cloudflare Nameservers查看cloudflare提供给我们的Nameservers:我的是：jade.ns.cloudflare.comskip.ns.cloudflare.com而后前往个人的域名服务商控制台，域名管理，DNS修改 =&gt; 将域名服务器改为cloudflare提供的Nameserver保存，可在whois.net上查看你的域名信息 可见是否正确修改</code></pre><h3 id="create-page-rules"><a href="#create-page-rules" class="headerlink" title="create page rules"></a>create page rules</h3><pre><code>cloudflare &gt;Page Rules &gt; create page rulehttp://*example.com/*匹配该规则的将会使用cloudflare服务，而 ↑ 的规则可以满足几乎所有要求</code></pre><h3 id="Last-step"><a href="#Last-step" class="headerlink" title="Last step"></a>Last step</h3><pre><code>wait a few minutes...你可以在控制台上 overview&gt;个人网站的status显示为Active (background green)你还可以设置强制使用https, 详细配置都在 cloudflare &gt; Crypto中</code></pre><hr><h2 id="Music-Bar"><a href="#Music-Bar" class="headerlink" title="Music-Bar"></a>Music-Bar</h2><hr><h3 id="功能分类"><a href="#功能分类" class="headerlink" title="功能分类"></a>功能分类</h3><p>　　jQuery功能的原生实现代码置于MusicBarService中：[参考 You Might Not Need jQuery( <a href="http://youmightnotneedjquery.com/" target="_blank" rel="noopener">http://youmightnotneedjquery.com/</a> )]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@Injectable()</span><br><span class="line">export class MusicBarService &#123;</span><br><span class="line">constructor() &#123;&#125;</span><br><span class="line">public addEvent(obj,type,handle)&#123; //添加 on 监听</span><br><span class="line">try&#123;// Chrome、FireFox、Opera、Safari、IE9.0及其以上版本</span><br><span class="line">obj.addEventListener(type,handle,false);</span><br><span class="line">&#125;catch(e)&#123;</span><br><span class="line">try&#123;  // IE8.0及其以下版本</span><br><span class="line">obj.attachEvent(&apos;on&apos; + type,handle);</span><br><span class="line">&#125;catch(e)&#123;  // 早期浏览器</span><br><span class="line">obj[&apos;on&apos; + type] = handle;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public removeClass(el,className)&#123;</span><br><span class="line">if (el.classList)</span><br><span class="line">  el.classList.remove(className);</span><br><span class="line">else</span><br><span class="line">  el.className = el.className.replace(new RegExp(&apos;(^|\\b)&apos; + className.split(&apos; &apos;).join(&apos;|&apos;) + &apos;(\\b|$)&apos;, &apos;gi&apos;), &apos; &apos;);</span><br><span class="line">&#125;</span><br><span class="line">public addClass(el,className)&#123;</span><br><span class="line">if (el.classList)</span><br><span class="line">  el.classList.add(className);</span><br><span class="line">else</span><br><span class="line">el.className += &apos; &apos; + className;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　HTMLDOM的操作置于app.component.ts[这显然需要改进，当前先凑合]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@Component(&#123;...&#125;)</span><br><span class="line">export class AppComponent &#123;</span><br><span class="line">//...</span><br><span class="line">public t:any;//定时器</span><br><span class="line">public lock:boolean=false;</span><br><span class="line">ngOnInit()&#123;</span><br><span class="line">this.slideToggle();</span><br><span class="line">this.lockToggle();</span><br><span class="line">&#125;</span><br><span class="line">public slideToggle()&#123;</span><br><span class="line">let that=this;</span><br><span class="line">this.musicBarSv.addEvent(document.getElementById(&quot;musicbar&quot;),&quot;mouseenter&quot;,mouseEnter);</span><br><span class="line">function mouseEnter()&#123;</span><br><span class="line">if(that.t)&#123;</span><br><span class="line">clearTimeout(that.t);</span><br><span class="line">&#125;</span><br><span class="line">let el=document.querySelectorAll(&quot;.slide-toggle&quot;);</span><br><span class="line">Array.prototype.forEach.call(el,function(v,i)&#123;</span><br><span class="line">(&lt;HTMLElement&gt;el[i]).style.bottom=&quot;0px&quot;;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">//... mouseLeave类似</span><br><span class="line">&#125;</span><br><span class="line">/*需要注意的有两点：</span><br><span class="line">1.typescript中querySeletor返回的的为Element类型而非HTMLElement,故通过&lt;HTMLElement&gt;el转化；</span><br><span class="line">2.querySeletorAll()选取多个，返回NodeList&lt;Element&gt;,调用Array的原型方法forEach,分别处理</span><br><span class="line">3.注意this的指向，当执行mouseEnter等回调函数时，上下文已经改变，this不在指向组件本身。故先将this保存-&gt; let that=this;</span><br><span class="line">*/</span><br><span class="line">public lockToggle()&#123;</span><br><span class="line">//... 需注意点 类似</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h3><p>　　先在angular-cli.json中声明所有静态文件(夹)</p><pre><code>&quot;assets&quot;: [    &quot;assets&quot;,    &quot;favicon.ico&quot;,    &quot;jsondata-store&quot;],</code></pre><p>　　而后就可以通过相对路径使用静态资源</p><pre><code>//app.component.css #d1{}background: url(&apos;../assets/12.svg&apos;);</code></pre><h3 id="Animation-and-Transition"><a href="#Animation-and-Transition" class="headerlink" title="Animation and Transition"></a>Animation and Transition</h3><p>　Animate关键帧<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//declare:</span><br><span class="line">@keyframes RotateAnimate &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">transform: rotate(0deg);</span><br><span class="line">&#125;</span><br><span class="line">50% &#123;</span><br><span class="line">transform: rotate(180deg);</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">transform: rotate(360deg);</span><br><span class="line">&#125;</span><br><span class="line">//or from&#123;....&#125; to&#123;....&#125;</span><br><span class="line">&#125;</span><br><span class="line">//using:</span><br><span class="line">div&#123;</span><br><span class="line">animation: RotateAnimate 5s linear infinite; //linear平缓过渡</span><br><span class="line">-webkit-animation:RotateAnimate 5s linear infinite;//chrome safari兼容</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　Transition:</p><pre><code>//改变值时的过渡动画.slide-toggle{    bottom: -60px;    transition:bottom 0.5s;//or transition:all 0.5s;}</code></pre><hr><p>　　愉快的开始,希望这周都能保存再接再厉…<br>　　月光之下无限连：咚咚１３咚３２３+ [1 and 3] or loop ．．．<br>　　稍显遗憾的是 近一个月”清心”的坚持 没能持续下去… Just do it , Never look back!!!</p><hr><hr><h2 id="——-END-———"><a href="#——-END-———" class="headerlink" title="—— END ———"></a>—— END ———</h2></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot;&gt;&lt;div class=&quot;.article-gallery&quot; &lt;blockquote=&quot;&quot;&gt;
&lt;h2 id=&quot;Beginning&quot;&gt;&lt;a href=&quot;#Beginning&quot; class=&quot;headerlink&quot; title=&quot;Beginning&quot;&gt;&lt;/a&gt;Beginning&lt;/h2&gt;
&lt;blockquote&gt;&lt;p&gt;独立的思想使你避免成为行尸走肉,别轻易地让他人影响你的想法 …&lt;/p&gt;
&lt;footer&gt;&lt;strong&gt;[Mark Tovin]&lt;/strong&gt;&lt;/footer&gt;&lt;/blockquote&gt;
&lt;hr&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;2017 年 9 月 11 日&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　新的一周，杭城已然褪去了夏天的炎热，你很难忍受多变的气温与空气的湿度。时而酷热难耐，时而又冷风淅淅…&lt;br&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://www.cpphonor.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="Diary" scheme="http://www.cpphonor.cn/categories/%E9%9A%8F%E7%AC%94/Diary/"/>
    
      <category term="Angular" scheme="http://www.cpphonor.cn/categories/%E9%9A%8F%E7%AC%94/Diary/Angular/"/>
    
    
      <category term="Diary" scheme="http://www.cpphonor.cn/tags/Diary/"/>
    
      <category term="Footprint" scheme="http://www.cpphonor.cn/tags/Footprint/"/>
    
  </entry>
  
  <entry>
    <title>Rx (Reactive Extensions)</title>
    <link href="http://www.cpphonor.cn/2017/09/10/RxJS/"/>
    <id>http://www.cpphonor.cn/2017/09/10/RxJS/</id>
    <published>2017-09-10T07:41:56.000Z</published>
    <updated>2017-11-30T14:14:56.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <blockquote=""><blockquote><p>拖着疲惫的身心熬夜苦干无异于饮鸠止渴…</p><footer><strong>[Chris Smart]</strong></footer></blockquote><hr><h2 id="何为响应式编程"><a href="#何为响应式编程" class="headerlink" title="何为响应式编程"></a>何为响应式编程</h2><hr><p>　　它是一种面向 变化传播(the Propagation of Change) 和 数据流(Data-Flow) 的编程范式</p><h3 id="变化传播"><a href="#变化传播" class="headerlink" title="变化传播"></a>变化传播</h3><pre><code>不同于命令式编程,当数据/状态发生改变时,它会根据最新的数据源计算新的结果, 如：    原本view1经过渲染后展现为result1, 现今将view1更新为view2,则引擎将会重新渲染view2,从而得到result2.</code></pre><a id="more"></a><h3 id="面向数据流编程"><a href="#面向数据流编程" class="headerlink" title="面向数据流编程"></a>面向数据流编程</h3><pre><code>将被封装成数据流对象的数据或事件，再对該流对象 进行 诸如map,filter,fork等一些列处理后，而后响应整个数据流的回调的过程。例：</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ObservableObj.map(...).subscribe(callback);</span><br></pre></td></tr></table></figure><hr><h2 id="Microsoft-Rx-系列"><a href="#Microsoft-Rx-系列" class="headerlink" title="Microsoft  Rx 系列"></a>Microsoft  Rx 系列</h2><hr><p>　　根据Reactive Programming范式，结合观察者模式，函数式编程，迭代器模式开发的工具库集合；它们提供了一系列接口规范以供开发者处理异步数据流.</p><h3 id="Observable"><a href="#Observable" class="headerlink" title="Observable:"></a>Observable:</h3><pre><code>1.数据流之源，将异步的数据或事件封装成Observable对象后才能进行后续操作通过Operator可方便地对Obs对象进行一系列处理，如映射，过滤等，生成新的Observable对象，并沿着新的Obs数据流通道 继续流向下游2.当上游的Observable数据流发生改变时，它将切断原先的的下游通道，使用新的通道3.一个Observable对象可封装多个异步数据流，并可以保证异步请求返回的顺序，防止响应的错乱4.创建Observable对象：</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable.fromEvent(DOMElem,&apos;eventName&apos;)</span><br><span class="line">.debounceTime(1000)//延迟响应</span><br><span class="line">.switchMap(event=&gt;&#123;&#125;)//保证请求返回顺序</span><br><span class="line">.subscribe(callback);</span><br></pre></td></tr></table></figure><p>　or:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Observable(observer=&gt;&#123;&#125;);</span><br></pre></td></tr></table></figure></p><pre><code>Observable作为 被观察者，需要通过subscribe()方法订阅，从而捕获Obs发送的事件，而 subscribe()中的callback方法 将接收observer调用next()方法后发来的数据，对捕获的事件进行处理操作；将所有对状态量的操作封装在各Operator函数中，体现了函数式编程的思想。Observable将响应的数据response传递给observer之前，可以先调用Operator对response进行处理。</code></pre><hr><h3 id="RxJS"><a href="#RxJS" class="headerlink" title="RxJS:"></a>RxJS:</h3><h4 id="与Promise的对比"><a href="#与Promise的对比" class="headerlink" title="与Promise的对比"></a>与Promise的对比</h4><pre><code>1. RxJS在功能上是Promise的超集，能够完美替代Promise2. RxJS允许以数据流的形式，响应多个异步事件，这是Promise所不具备的</code></pre><h4 id="“冷模式”下的Observable"><a href="#“冷模式”下的Observable" class="headerlink" title="“冷模式”下的Observable"></a>“冷模式”下的Observable</h4><pre><code>在被订阅(subscribe)前，不会发送数据流&quot;热模式&quot;的Observable则在Obs对象创建时被开始发送</code></pre><h4 id="“Connectable模式”"><a href="#“Connectable模式”" class="headerlink" title="“Connectable模式”"></a>“Connectable模式”</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let obs=new Observable(observer=&gt;&#123;...; observer.next(); ...&#125;).publish();</span><br><span class="line">//publish可将Obs转换为connectable模式</span><br><span class="line">//当调用 obs.connect() 时才开始发送</span><br></pre></td></tr></table></figure><h4 id="Operators-of-RxJS"><a href="#Operators-of-RxJS" class="headerlink" title="Operators of RxJS"></a>Operators of RxJS</h4><pre><code>创建操作符：- Rx.Observable.create(observer=&gt;{factory()})变换操作符:- obs.map(res=&gt;{}).subscribe(data=&gt;{});  先对响应的数据res进行映射操作，再传给observer过滤操作符：- obs.filter(res=&gt;{return booleanExp;})..... 返回值为false的数据将不会继续向下流组合操作符：- obs=Rx.Observable.forkJoin(obs1,obs2);  将两个独立的Obs对象合并为一个新的Obs对象，并且在两个Obs对象的数据都抵达后才会开始进行合并处理;- obs=firstObs.concatMap(firstData=&gt;{    return Rx.Observable.create(observer=&gt;{          factory(firstData,secondData=&gt;{})        });  })...  后一次请求需要依赖前一次请求的结果，借用concatMap操作符，将first数据流紧接在second数据流之后工具操作符：- timeout(),delay(),debounceTime(),distinctUntilChanged()...</code></pre><h4 id="Angular-with-RxJS"><a href="#Angular-with-RxJS" class="headerlink" title="Angular with RxJS"></a>Angular with RxJS</h4><blockquote><p>例：改造HTTP服务(《揭秘Angular2》 p265~266)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Injectable()</span><br><span class="line">export class MyHttpService&#123;</span><br><span class="line">constructor(private http:Http)&#123;&#125;</span><br><span class="line"></span><br><span class="line">get(url:string,reqOpts?: RequestOptions)&#123;</span><br><span class="line">return this.request(url,Object.assign(&#123;</span><br><span class="line">method:&apos;get&apos;</span><br><span class="line">&#125;,reqOpts));</span><br><span class="line">&#125;</span><br><span class="line">//... post delete update</span><br><span class="line">request(url:string,reqOpts:RequestOptions)&#123;</span><br><span class="line">this.showLoading(); //开启加载动画</span><br><span class="line">return this.http.request(url,new RequestOptions(reqOpts))</span><br><span class="line">.map(res=&gt;res.json())</span><br><span class="line">.do(this.hideLoading.bind(this)) //关闭加载动画</span><br><span class="line">.map(this.preprocessRes.bind(this)) //对返回数据进行统一的预处理</span><br><span class="line">.catch(this.handleErr.bind(this)); //对请求错误进行统一处理</span><br><span class="line">&#125;</span><br><span class="line">private preprocessRes(res)&#123;</span><br><span class="line">//return ....</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><hr><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot;&gt;&lt;div class=&quot;.article-gallery&quot; &lt;blockquote=&quot;&quot;&gt;
&lt;blockquote&gt;&lt;p&gt;拖着疲惫的身心熬夜苦干无异于饮鸠止渴…&lt;/p&gt;
&lt;footer&gt;&lt;strong&gt;[Chris Smart]&lt;/strong&gt;&lt;/footer&gt;&lt;/blockquote&gt;

&lt;hr&gt;
&lt;h2 id=&quot;何为响应式编程&quot;&gt;&lt;a href=&quot;#何为响应式编程&quot; class=&quot;headerlink&quot; title=&quot;何为响应式编程&quot;&gt;&lt;/a&gt;何为响应式编程&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;　　它是一种面向 变化传播(the Propagation of Change) 和 数据流(Data-Flow) 的编程范式&lt;/p&gt;
&lt;h3 id=&quot;变化传播&quot;&gt;&lt;a href=&quot;#变化传播&quot; class=&quot;headerlink&quot; title=&quot;变化传播&quot;&gt;&lt;/a&gt;变化传播&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;不同于命令式编程,当数据/状态发生改变时,它会根据最新的数据源计算新的结果, 如：
    原本view1经过渲染后展现为result1, 现今将view1更新为view2,则引擎将会重新渲染view2,从而得到result2.
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Rx" scheme="http://www.cpphonor.cn/categories/Rx/"/>
    
      <category term="Angular" scheme="http://www.cpphonor.cn/categories/Rx/Angular/"/>
    
    
      <category term="RxJS" scheme="http://www.cpphonor.cn/tags/RxJS/"/>
    
  </entry>
  
  <entry>
    <title>Footprint</title>
    <link href="http://www.cpphonor.cn/2017/09/07/footprint-17-09-07/"/>
    <id>http://www.cpphonor.cn/2017/09/07/footprint-17-09-07/</id>
    <published>2017-09-07T15:59:16.000Z</published>
    <updated>2018-07-07T14:28:02.855Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <blockquote=""><h2 id="Beginning"><a href="#Beginning" class="headerlink" title="Beginning"></a>Beginning</h2><blockquote><p>在竭尽全力之前,无需太过在意结果,一切应当顺其自然 …</p><footer><strong>[Blues Lee]</strong></footer></blockquote><hr><hr><blockquote><p>2017 年 9 月 7 日</p></blockquote><p>　　拖了快接近一周，终于再次静下心来书写新一篇博客…<br><a id="more"></a><br>　　这周的关键词为‘移动’、‘单’、‘志愿者’、‘劳累的身体与舒畅的心’… 总结起来,受益匪浅。<br>　　接下来，主要的工作，Re-Music的进展：</p><blockquote><ul><li>不错的开头，搜索功能基本实现</li><li>搜索和播放列表的样式美化</li><li>获取特定用户的“我的最爱”列表</li><li>歌词的获取与同步-（测试）</li></ul></blockquote><hr><h2 id="搜索功能的实现"><a href="#搜索功能的实现" class="headerlink" title="搜索功能的实现"></a>搜索功能的实现</h2><p>　　1.重新划分了模块，将点击歌曲链接后的处理逻辑放到了service中<br>　　2.对用户”最爱列表”的每首歌曲的创建时间进行处理<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//inside playlist.component.ts</span><br><span class="line">public loadData(searchText:string=<span class="string">""</span>)&#123;</span><br><span class="line"><span class="built_in">return</span> this.playlistService.getFavorite().subscribe(</span><br><span class="line">res=&gt;&#123;</span><br><span class="line">this.playList = res.slice();</span><br><span class="line">this.playList.forEach(<span class="keyword">function</span>(value,index,arr)&#123;//&lt;--Here</span><br><span class="line">arr[index].createtime=(new Date(arr[index].createtime*1000)).toLocaleString();//&lt;--</span><br><span class="line">&#125;);</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>　　</p><h2 id="列表的美化"><a href="#列表的美化" class="headerlink" title="列表的美化"></a>列表的美化</h2><p>　　1.自定义了管道 longTextFilterPipe, 放置于共享模块 share.module.ts<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Pipe, PipeTransform &#125; from <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line">@Pipe(&#123;</span><br><span class="line">name: <span class="string">'longTextFilter'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">export</span> class LongTextFilterPipe implements PipeTransform &#123;</span><br><span class="line">transform(value: string, <span class="built_in">limit</span>: number): any &#123;</span><br><span class="line"><span class="keyword">if</span>(value.length&gt;<span class="built_in">limit</span>) &#123;</span><br><span class="line"><span class="built_in">return</span> value.slice(0,<span class="built_in">limit</span>)+<span class="string">"..."</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　2.自定义Pipe需要在某个module的declarations中声明，且只能包含与一个module，故最好的方案就是将其集成到共享模块中，而后需要用到該管道的module中import即可使用{express|longTextFilter}<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//inside share.module.ts</span><br><span class="line">@NgModule(&#123;</span><br><span class="line">imports:[</span><br><span class="line">CommonModule</span><br><span class="line">],</span><br><span class="line">declarations:[</span><br><span class="line">LongTextFilterPipe</span><br><span class="line">],</span><br><span class="line">exports:[</span><br><span class="line">LongTextFilterPipe</span><br><span class="line">]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>　　3.列表元素-歌曲链接-改为button,使用btn-link样式</p><h2 id="歌词的获取并同步功能"><a href="#歌词的获取并同步功能" class="headerlink" title="歌词的获取并同步功能"></a>歌词的获取并同步功能</h2><h3 id="—待集成—"><a href="#—待集成—" class="headerlink" title="    —待集成—    "></a><em> </em> <em> </em> <em>—待集成—</em> <em> </em> <em> </em></h3><h2 id="FOCUS-ON"><a href="#FOCUS-ON" class="headerlink" title="FOCUS ON"></a>FOCUS ON</h2><p>　　Chrome中的audio标签src属性使用音乐外链无法获取源，而Edge中是可行的。这也许需要重新考虑是否使用html5原生的audio标签。现今先使用Edge测试，后期将改用通用的方案。<br>　　TODO:</p><ul><li style="list-style: none"><input type="checkbox"> 集成歌词同步功能</li><li style="list-style: none"><input type="checkbox"> 歌词滚动效果</li><li style="list-style: none"><input type="checkbox"> Angular指令</li></ul><hr><hr><p>　　唯有时刻不停的努力，才能获取机遇的青睐…Keep fighting!!!</p><h2 id="——-END-———"><a href="#——-END-———" class="headerlink" title="—— END ———"></a>—— END ———</h2></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot;&gt;&lt;div class=&quot;.article-gallery&quot; &lt;blockquote=&quot;&quot;&gt;
&lt;h2 id=&quot;Beginning&quot;&gt;&lt;a href=&quot;#Beginning&quot; class=&quot;headerlink&quot; title=&quot;Beginning&quot;&gt;&lt;/a&gt;Beginning&lt;/h2&gt;
&lt;blockquote&gt;&lt;p&gt;在竭尽全力之前,无需太过在意结果,一切应当顺其自然 …&lt;/p&gt;
&lt;footer&gt;&lt;strong&gt;[Blues Lee]&lt;/strong&gt;&lt;/footer&gt;&lt;/blockquote&gt;
&lt;hr&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;2017 年 9 月 7 日&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　拖了快接近一周，终于再次静下心来书写新一篇博客…&lt;br&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://www.cpphonor.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="Diary" scheme="http://www.cpphonor.cn/categories/%E9%9A%8F%E7%AC%94/Diary/"/>
    
    
      <category term="Diary" scheme="http://www.cpphonor.cn/tags/Diary/"/>
    
      <category term="Footprint" scheme="http://www.cpphonor.cn/tags/Footprint/"/>
    
  </entry>
  
  <entry>
    <title>Footprint</title>
    <link href="http://www.cpphonor.cn/2017/09/02/footprint-17-09-02/"/>
    <id>http://www.cpphonor.cn/2017/09/02/footprint-17-09-02/</id>
    <published>2017-09-02T15:13:12.000Z</published>
    <updated>2017-11-30T14:04:16.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <blockquote=""><h2 id="Beginning"><a href="#Beginning" class="headerlink" title="Beginning"></a>Beginning</h2><blockquote><p>人总喜欢活在昨天 …</p><footer><strong>[Mamen Tristan]</strong></footer></blockquote><hr><hr><blockquote><p>2017 年 9 月 2 日</p></blockquote><p>　　周末的我, 没有如同以往赖床到正午, 这也许是今天最大的闪光点！然而, 这也许就意味着，今天一事无成…<br><a id="more"></a></p><p>　　好吧, 终归还是有学一点的(内心自我安慰道),荀子曾经曰过：虽为硅步，积也成机。废话不多说,转入正题：</p><p>　　总结一下这两天：</p><blockquote><ul><li>解决lg-thumbnail和lg-fullscreen插件不可用的问题</li><li>解决youyan用户评论内容不可见问题</li><li>关于hexo的博客的各种插件，各主题中配置会有所不同，此时查看在相应插件的源代码</li><li>Angular 模板 数据绑定 与 内置指令</li></ul></blockquote><hr><h2 id="Angular-模板"><a href="#Angular-模板" class="headerlink" title="Angular 模板"></a>Angular 模板</h2><hr><h3 id="关于模板"><a href="#关于模板" class="headerlink" title="关于模板"></a>关于模板</h3><p>　　其上下文环境为该组件实例本身[一个标签，一个实例]，即模板中一般只能访问該组件的属性（模板局部变量#，事件绑定参数$event则可以来自组件之外）</p><hr><h3 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h3><p>　　分单向数据流（事件绑定，属性绑定），双向数据绑定 两类</p><h4 id="模板表达式："><a href="#模板表达式：" class="headerlink" title="模板表达式："></a>模板表达式：</h4><p>　　类似js表达式，但需避免以下用法：</p><pre><code>带有new 赋值表达式  ( [target]=&quot;some=exp&quot; ) 或 自增自减带有“;”或“,”的链式表达式 （多条表达式 exp1;exp2;exp3）不支持位运算|和&amp;简言之：应使用简洁高效的语句，应只改变目标属性的值（不在其中改变其他逻辑），适时使用缓存，幂等性优先　　部分操作符被赋予了新的意义，如&quot;|&quot;为管道操作符，&quot;？.&quot;则为安全导航操作 如 a?.prop 则允许a不具prop属性</code></pre><hr><h3 id="属性绑定"><a href="#属性绑定" class="headerlink" title="属性绑定"></a>属性绑定</h3><pre><code>DOM元素：直接使用 [target]=&quot;exp&quot; or  target=&quot;expstr&quot;HTML标签的特性（如colspan等非DOM属性）：使用[attr.target]=&quot;exp&quot;  CSS类： 既属于DOM属性又属于HTML标签特性，故两种方式均可，但：    [class]=&quot;exp&quot; 将覆盖 &gt; class=&quot;className&quot;  exp将重写改模版元素的全部class    [class.classname]=&quot;boolfunc()&quot;  通过返回值来决定添加或者移除該 classnamestyle样式绑定：[style.style-property]=&quot;exp&quot;     可同时带上样式单位：[style.width.%]=&quot;isHalf?:100:50&quot; ; =&gt; (isHalf==true)then width=100%    属性样式可使用 background-color形式 或驼峰式： backgroundColor;</code></pre><h4 id="属性绑定与插值："><a href="#属性绑定与插值：" class="headerlink" title="属性绑定与插值："></a>属性绑定与插值：</h4><p>　　插值终将转换为属性绑定，两者都会对绑定内容进行安全检测 看是否有脚本之类的，有则会进行过滤</p><hr><h3 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h3><pre><code>表达式：    支持带&quot;;&quot; or &quot;,&quot;的链式表达式    仅支持 “=”赋值 其他“+= -=”等操作不支持 自增自减也不支持    其他与属性绑定同优先级：自定义指令&gt;元素事件（click等）$event事件对象：包含触发的事件的相关信息，根据目标事件的类型，事件对象的形态也会不同：    原生DOM元素事件触发：$event为 包含target和target.value属性的DOM事件对象;(click) or on-click    自定义事件触发：        需借助子组件EventEmitter实例对象 设为@output()routeEM = new EventEmitter&lt;paramType&gt;();        父组件通过绑定該输出属性(routeEM)以自定义事件，(routeEM)=&quot;fixMethod($event)&quot;        子组件中可通过routeEM.emit(payload)触发該事件，payload可为任何值.         父组件的处理方法fixMethod通过$event访问payload数据</code></pre><hr><h3 id="双向数据绑定：-多用于表单控件如-lt-input-gt"><a href="#双向数据绑定：-多用于表单控件如-lt-input-gt" class="headerlink" title="双向数据绑定：(多用于表单控件如&lt; input&gt;)"></a>双向数据绑定：(多用于表单控件如&lt; input&gt;)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">①[value]=<span class="string">"cur.num"</span>  (input)=<span class="string">"cur.num=<span class="variable">$event</span>.target.value"</span></span><br><span class="line">↓↓</span><br><span class="line">②[ngModel]=<span class="string">"cur.num"</span>  (ngModelChange)=<span class="string">"cur.num=<span class="variable">$event</span>"</span>   【此处<span class="variable">$event</span>形式不同于①】</span><br><span class="line">↓↓</span><br><span class="line">③[(ngModel)]=<span class="string">"cur.num"</span>  或前缀写法 bindon-ngModel=<span class="string">"cur.num"</span></span><br></pre></td></tr></table></figure><p>其中方法②较③灵活，他可以完成不同的任务：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ngModel]="cur.num" (ngModelChange)="methodAddNum($event)"</span><br></pre></td></tr></table></figure></p><hr><h3 id="内置指令"><a href="#内置指令" class="headerlink" title="内置指令"></a>内置指令</h3><blockquote><p>　　Angular中有一系列内置指令，熟练运用可减少很多额外的工作</p></blockquote><p>NgClass:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[ngClass]="setClassFunc()" </span><br><span class="line">setClassFunc()&#123;</span><br><span class="line">let classes=&#123;red:this.red,font14:this.font14&#125; </span><br><span class="line">&#125;</span><br><span class="line">//根据this.red this.font14的值确定是否添加該class</span><br></pre></td></tr></table></figure></p><p>NgStyle:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ngStyle]=&quot;setStyleFunc()&quot; //=&gt;形如 let styles=&#123;&apos;color&apos;:this.red?&apos;red&apos;:&apos;blue&apos;&#125;</span><br></pre></td></tr></table></figure></p><p>NgIf:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*ngIf=&quot;exp&quot;  // if exp==false  該元素会被移除</span><br></pre></td></tr></table></figure></p><p>NgSwitch:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> [<span class="attr">ngSwitch</span>]=<span class="string">"exp"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> *<span class="attr">ngSwitchCase</span>=<span class="string">" 'val1' "</span>&gt;</span> fasdfa <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> *<span class="attr">ngSwitchDefault</span>&gt;</span>fasdfds <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>NgFor:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div *ngFor=<span class="string">"let con of cons; let i=index; trackBy:trackByFunc"</span>&gt; &#123;&#123;con.id&#125;&#125; &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">trackByFunc(index:number,con:Contact)&#123;</span><br><span class="line"><span class="built_in">return</span> con.id</span><br><span class="line">&#125;;</span><br><span class="line">/*trackBy为追踪函数，該函数检测对应的属性 [此处con.id] 是否改变，改变则更新該元素，否则不变</span><br><span class="line">index 为当前con的索引*/</span><br></pre></td></tr></table></figure></p><hr><hr><hr><p>　　尽管增长甚少，却也在积累当中，也算是重回正轨了，接下来的工作是完成Ｒｅ－Ｍｕｓｉｃ项目…never look back…</p><h2 id="——-END-———"><a href="#——-END-———" class="headerlink" title="—— END ———"></a>—— END ———</h2></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot;&gt;&lt;div class=&quot;.article-gallery&quot; &lt;blockquote=&quot;&quot;&gt;
&lt;h2 id=&quot;Beginning&quot;&gt;&lt;a href=&quot;#Beginning&quot; class=&quot;headerlink&quot; title=&quot;Beginning&quot;&gt;&lt;/a&gt;Beginning&lt;/h2&gt;
&lt;blockquote&gt;&lt;p&gt;人总喜欢活在昨天 …&lt;/p&gt;
&lt;footer&gt;&lt;strong&gt;[Mamen Tristan]&lt;/strong&gt;&lt;/footer&gt;&lt;/blockquote&gt;
&lt;hr&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;2017 年 9 月 2 日&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　周末的我, 没有如同以往赖床到正午, 这也许是今天最大的闪光点！然而, 这也许就意味着，今天一事无成…&lt;br&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://www.cpphonor.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="Diary" scheme="http://www.cpphonor.cn/categories/%E9%9A%8F%E7%AC%94/Diary/"/>
    
    
      <category term="Diary" scheme="http://www.cpphonor.cn/tags/Diary/"/>
    
      <category term="Footprint" scheme="http://www.cpphonor.cn/tags/Footprint/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://www.cpphonor.cn/2017/09/01/hello-world/"/>
    <id>http://www.cpphonor.cn/2017/09/01/hello-world/</id>
    <published>2017-08-31T16:27:10.000Z</published>
    <updated>2017-08-31T16:27:10.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <p="">Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.<p></p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a><br><a id="more"></a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save //need install hexo-deployer-git first</span><br><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot;&gt;&lt;div class=&quot;.article-gallery&quot; &lt;p=&quot;&quot;&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;p&gt;&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&quot;My New Post&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/writing.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Writing&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Hexo" scheme="http://www.cpphonor.cn/categories/Hexo/"/>
    
      <category term="Start" scheme="http://www.cpphonor.cn/categories/Hexo/Start/"/>
    
    
  </entry>
  
  <entry>
    <title>Footprint</title>
    <link href="http://www.cpphonor.cn/2017/08/31/footprint-17-08-31/"/>
    <id>http://www.cpphonor.cn/2017/08/31/footprint-17-08-31/</id>
    <published>2017-08-31T14:13:35.000Z</published>
    <updated>2017-11-30T14:11:24.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <blockquote=""><h2 id="Beginning"><a href="#Beginning" class="headerlink" title="Beginning"></a>Beginning</h2><blockquote><p>水净自清, 活水源头 …</p><footer><strong>[Kali Antsen]</strong></footer></blockquote><hr><hr><blockquote><p>2017 年 8 月 31 日</p></blockquote><p>　　有逢周四，本想早点出行，却是睡到近11点才醒来，更是到快13点才不甘愿地起床。所有的这些都是为了完成一个任务，那就是“活得如同人应当活的样子 - 进食”。<br><a id="more"></a></p><p>　　当然，赖床并非本愿，是有原因的。我在凌晨３：３０后才入睡，至于为什么，我猜是喝了那杯传说中的‘英国红茶’，还有不小心看了令人停不下来的 银魂真人版，这是真的搞笑。好了，言归正传：</p><p>　　总结一下这两天：</p><blockquote><ul><li>rss源订阅</li><li>总算实现了个人博客的相册，中间踩了很多坑，但是还是值得高兴的</li><li>使用swiftype 为博客添加了站内搜索功能</li></ul></blockquote><hr><h2 id="RSS源订阅"><a href="#RSS源订阅" class="headerlink" title="ＲＳＳ源订阅:"></a>ＲＳＳ源订阅:</h2><pre><code>在theme._config.yml 简单地打开了开关，配置</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-feed --save //安装插件</span><br></pre></td></tr></table></figure><pre><code>plugins:     hexo-generator-feed    hexo-light-gallerysubnav:    rss:/atom.xml //图标，链接# Customize feed link 自定义订阅地址rss: /atom.xmlfeed:    type: atom    path: atom.xml    limit: 20</code></pre><hr><h2 id="个人相册"><a href="#个人相册" class="headerlink" title="个人相册"></a>个人相册</h2><p>使用instagram未果，转而使用 七牛云存储。</p><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-qiniu-sync --save //切勿添加到plugins:依赖，否则可能报错</span><br></pre></td></tr></table></figure><p>配置说明如下(hexo._config.yml)：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">qiniu:</span><br><span class="line">  offline: <span class="literal">false</span> //是否处于离线状态</span><br><span class="line">  sync: <span class="literal">true</span> //同步</span><br><span class="line">  bucket: freemansj //bucket name</span><br><span class="line">  secret_file: qiniu_sec/secretkey.json</span><br><span class="line">  dirPrefix: images //资源存储目录 根据image:folder选项和urlPrefix选项综合考虑</span><br><span class="line">  urlPrefix: http://ovge5llkw.bkt.clouddn.com/images //外链前缀</span><br><span class="line">  up_host: http://upload.qiniu.com/images //上传地址</span><br><span class="line">  local_dir: qiniu //本地目录（Blog主目录而非子目录）</span><br><span class="line">  update_exist: <span class="literal">false</span> //静态文件是否可能修改，并且重上传</span><br><span class="line">  //以下的folder配置均为静态资源种类的目录名称，一般不用修改</span><br><span class="line">  image: </span><br><span class="line">    folder: <span class="string">''</span> //必须有string值不然报错</span><br><span class="line">    extend: </span><br><span class="line">  js:</span><br><span class="line">    folder: js</span><br><span class="line">  css:</span><br><span class="line">    folder: css</span><br></pre></td></tr></table></figure></p><h3 id="引用图片"><a href="#引用图片" class="headerlink" title="引用图片"></a>引用图片</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% qnimg imagename.(jpg|png|...) title:imgtitle alt:altinfo <span class="string">'class:gallery-pic'</span> extend:?imageView2/0/q/100|imageslim %&#125;</span><br></pre></td></tr></table></figure><pre><code>图片路径会根据配置中的外链和dirPrefix信息自动补全extend为图片样式接口渲染结果：&lt;img title=&quot;图片标题&quot; class=&quot;class1 class2&quot; src=&quot;http://ovge5llkw.bkt.clouddn.com/images/demo.png?imageView2/0/q/100|imageslim&quot;&gt;</code></pre><h3 id="相片浏览插件：lightgallery"><a href="#相片浏览插件：lightgallery" class="headerlink" title="相片浏览插件：lightgallery"></a>相片浏览插件：lightgallery</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-light-gallery</span><br></pre></td></tr></table></figure><p>在theme.config或hexo.config中配置：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">lightgallery:</span><br><span class="line">    <span class="comment"># if you don't specify the css or js source, the default cdn will be used.</span></span><br><span class="line">    <span class="comment"># css: # css source url</span></span><br><span class="line">    <span class="comment"># js: #js source url</span></span><br><span class="line">    <span class="comment"># sorry that I can not find any cdn hosting following plugins,</span></span><br><span class="line">    <span class="comment"># please self-host the plugin js and add url here</span></span><br><span class="line">    plugins:</span><br><span class="line">      lg-thumbnail: /js/lg-thumbnail.min.js</span><br><span class="line">      lg-zoom: /js/lg-zoom.min.js</span><br><span class="line">        <span class="comment"># lg-autoplay:</span></span><br><span class="line">      lg-fullscreen: /js/lg-fullscreen.min.js</span><br><span class="line">        <span class="comment"># lg-pager:</span></span><br><span class="line">/*它将自动在每个页面中添加該引入lightgallery插件和它的样式*/</span><br><span class="line">/*添加zoom插件出错，测试了2个多小时仍没有结果*/</span><br><span class="line">/*一般，依赖的js文件*/</span><br></pre></td></tr></table></figure></p><h3 id="Lazyload"><a href="#Lazyload" class="headerlink" title="Lazyload:"></a>Lazyload:</h3><p>如何愉快实现图片的懒加载呢?  try jquery.lazyload.js<br>插件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">npm install jquery_lazyload --save</span><br><span class="line">/*然而一直不知道文件路径到底如何设置才能正确在页面中引用node_modules中的内容</span><br><span class="line">故可以考虑，下载之后 拷贝一份放置在 <span class="built_in">source</span>/js 中</span><br><span class="line">或者 直接使用cdn :</span><br><span class="line"></span><br><span class="line">&lt;script src=<span class="string">"https://cdn.bootcss.com/jquery/1.11.3/jquery.min.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=<span class="string">"https://cdn.bootcss.com/jquery_lazyload/1.9.1/jquery.lazyload.min.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></p><p>在文章中使用头部使用html的页面元素如div标签总会各种出错，link和script则不会<br>代码实现：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;img class=<span class="string">"lazy"</span> data-original=<span class="string">"http://ovge5llkw.bkt.clouddn.com/images/2016champion.jpg?imageView2/0/q/100|imageslim"</span>&gt;</span><br><span class="line">/*data-original为图片真实地址 此属性名是可自设置的，具体百度*/</span><br><span class="line">&lt;script src=<span class="string">"https://cdn.bootcss.com/jquery/1.11.3/jquery.min.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=<span class="string">"https://cdn.bootcss.com/jquery_lazyload/1.9.1/jquery.lazyload.min.js"</span>&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">jQuery(<span class="keyword">function</span>($) &#123;</span><br><span class="line">    $(<span class="string">".lazy"</span>).lazyload(&#123;</span><br><span class="line">    effect: <span class="string">"fadeIn"</span>, //加载效果</span><br><span class="line">    failure_limit : 10, //加载容错</span><br><span class="line">      load: <span class="keyword">function</span>(elem,l,o)&#123; //加载成功回调 三个参数似乎并用不上</span><br><span class="line">      <span class="variable">$this</span>=$(this); //this指向为当前dom元素 &lt;img&gt;</span><br><span class="line">      <span class="variable">$this</span>.addClass(<span class="string">'gallery-pic'</span>);</span><br><span class="line">      <span class="variable">$this</span>.parent(<span class="string">'a'</span>).attr(<span class="string">"href"</span>,<span class="variable">$this</span>.attr(<span class="string">"data-original"</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    $(<span class="string">"img.lazy"</span>).parent().unwrap(<span class="string">'p'</span>);</span><br><span class="line"> &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><pre><code>懒加载的图片被包装在 &lt;p&gt;&lt;a&gt;&lt;a/&gt;&lt;/p&gt;中:    由于lightgallery可用需要 a的href属性，故设置为img的data-original属性值    用unwrap方法去掉&lt;a&gt;&lt;img&gt;&lt;/a&gt;的包装层p,否则会导致样式问题为了使用$().lazyload() 需使用免冲突的写法 即jQuery(function($){});.gallery-pic 类的 样式使用了 固定宽高度自适应 图片的排列较为可控</code></pre><h2 id="站内搜索"><a href="#站内搜索" class="headerlink" title="站内搜索"></a>站内搜索</h2><h3 id="注册-swiftype"><a href="#注册-swiftype" class="headerlink" title="注册 swiftype"></a>注册 swiftype</h3><p>试用14天，到期后是否不可用此时仍未知，据说会退为免费用户，但仍可使用<br>install to website: 代码在 <code>layout/_partial/after-footer.ejs</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;% <span class="keyword">if</span> (theme.search_box)&#123; %&gt;</span><br><span class="line">   &lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">     window.onload = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">       document.getElementById(<span class="string">"search"</span>).onclick = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">           console.log(<span class="string">"search"</span>)</span><br><span class="line">           search();</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">function</span> <span class="function"><span class="title">search</span></span>()&#123;</span><br><span class="line">     /*--------逻辑添加此处----------*/</span><br><span class="line">         (<span class="keyword">function</span>(w,d,t,u,n,s,e)&#123;w[<span class="string">'SwiftypeObject'</span>]=n;w[n]=w[n]||<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">             (w[n].q=w[n].q||[]).push(arguments);&#125;;s=d.createElement(t);</span><br><span class="line">             e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);</span><br><span class="line">         &#125;)(window,document,<span class="string">'script'</span>,<span class="string">'//s.swiftypecdn.com/install/v2/st.js'</span>,<span class="string">'_st'</span>);</span><br><span class="line">         _st(<span class="string">'install'</span>,<span class="string">'XrQ3mzPiXyhmigRqyayY'</span>,<span class="string">'2.0.0'</span>);</span><br><span class="line">       /*---------------------------*/</span><br><span class="line">     &#125;</span><br><span class="line">   &lt;/script&gt;</span><br><span class="line">&lt;%&#125;%&gt;</span><br></pre></td></tr></table></figure></p><h3 id="配置"><a href="#配置" class="headerlink" title="配置:"></a>配置:</h3><pre><code># 是否显示边栏中的搜索框（仅样式，未添加搜索功能）# Search Box in left columnsearch_box: true //结合上面的代码 if(theme.search_box){} 便知一二</code></pre><hr><hr><hr><p>　　最后的最后，今天圆满结束，明天需更加努力工作…生活仍在继续…听keep on放松一下</p><h2 id="——-END-———"><a href="#——-END-———" class="headerlink" title="—— END ———"></a>—— END ———</h2></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot;&gt;&lt;div class=&quot;.article-gallery&quot; &lt;blockquote=&quot;&quot;&gt;
&lt;h2 id=&quot;Beginning&quot;&gt;&lt;a href=&quot;#Beginning&quot; class=&quot;headerlink&quot; title=&quot;Beginning&quot;&gt;&lt;/a&gt;Beginning&lt;/h2&gt;
&lt;blockquote&gt;&lt;p&gt;水净自清, 活水源头 …&lt;/p&gt;
&lt;footer&gt;&lt;strong&gt;[Kali Antsen]&lt;/strong&gt;&lt;/footer&gt;&lt;/blockquote&gt;
&lt;hr&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;2017 年 8 月 31 日&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　有逢周四，本想早点出行，却是睡到近11点才醒来，更是到快13点才不甘愿地起床。所有的这些都是为了完成一个任务，那就是“活得如同人应当活的样子 - 进食”。&lt;br&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://www.cpphonor.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="Diary" scheme="http://www.cpphonor.cn/categories/%E9%9A%8F%E7%AC%94/Diary/"/>
    
    
      <category term="Diary" scheme="http://www.cpphonor.cn/tags/Diary/"/>
    
      <category term="Footprint" scheme="http://www.cpphonor.cn/tags/Footprint/"/>
    
  </entry>
  
  <entry>
    <title>Footprint</title>
    <link href="http://www.cpphonor.cn/2017/08/30/footprint-17-08-29/"/>
    <id>http://www.cpphonor.cn/2017/08/30/footprint-17-08-29/</id>
    <published>2017-08-29T17:23:06.000Z</published>
    <updated>2017-08-31T16:37:28.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <blockquote=""><h2 id="The-Happy-Beginning"><a href="#The-Happy-Beginning" class="headerlink" title="The Happy Beginning"></a>The Happy Beginning</h2><blockquote><p>工作能够稀释身心的毒素，使人得到升华…</p><footer><strong>[Inamori Kazuo]</strong></footer></blockquote><hr><hr><blockquote><p>2017 年 8 月 29 日</p></blockquote><p>　　难得的早起，却是没能够充分利用这样的时间。</p><p>　　清晨的空气是清新的，良好的作息带来规律的饮食，由此产生了身体和心灵上的愉悦。睡眠稍显不足，不过一杯龙井下肚便令人摆脱了睡意，开始博客的重搭建。</p><a id="more"></a><p>   博客的搭建之路仍然不会是一帆风顺地进行，本地的遗留代码令人揪心，没能果断放弃浪费了不少时间。不过心里还算有底，收藏的一些hexo搭建个人博客的文章，加上潜在的记忆，搭建一个更为完美的博客还是有信心的。固然内心还是觉得有点麻烦。</p><h2 id="重温-git-的一些操作"><a href="#重温-git-的一些操作" class="headerlink" title="重温 git 的一些操作:"></a>重温 git 的一些操作:</h2><table><thead><tr><th>Name</th><th style="text-align:center">With/Parmas</th><th style="text-align:center">Effects</th></tr></thead><tbody><tr><td>clone</td><td style="text-align:center">uri.git</td><td style="text-align:center">克隆项目</td></tr><tr><td>add</td><td style="text-align:center">–all/-A</td><td style="text-align:center">添加修改</td></tr><tr><td>commit</td><td style="text-align:center">-m “message”</td><td style="text-align:center">提交+信息</td></tr><tr><td>reset</td><td style="text-align:center">–hard HEAD^/commit-id</td><td style="text-align:center">HEAD^回退一个版本,^^两个</td></tr></tbody></table><hr><h2 id="Time-Waste"><a href="#Time-Waste" class="headerlink" title="Time Waste"></a>Time Waste</h2><p>　　原本预计一个上午搞定，却是拖到了晚上仍在奋斗，其中有不少浪费时间的点:</p><blockquote><ul><li>主题的选择: 想着高大上，犹如选择恐惧症患者，迟迟不能做决定</li><li>主题的配置查看: 有的主题的文档忽略了很多配置的细节，调试困难</li><li>测试预览: 每次刷新10s来计算，上百次的刷新就是近20分钟<ul><li>需要记住的是，当仅仅修改css或者链接源的时候，保存后可直接刷新浏览器查看</li></ul></li><li>spfk主题，也是现有的主题，花费的时间和精力最多，就为了修改链接样式和背景颜色</li></ul></blockquote><hr><h2 id="Client申请的痛"><a href="#Client申请的痛" class="headerlink" title="Client申请的痛"></a>Client申请的痛</h2><p>　　Discus和Instgram的api的使用是个痛，几乎耗费了整个晚间。结果是没能申请成功。</p><p>　　相册最终选择了以七牛云存储为数据存储空间，本地上传，再在文章中引用該链接:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![alt-message](uri)</span><br></pre></td></tr></table></figure></p><p>  总算是成功了。需要优化的还有:</p><ul><li style="list-style: none"><input type="checkbox"> thumbnail 的实现</li><li style="list-style: none"><input type="checkbox"> lightgallery 使用</li><li style="list-style: none"><input type="checkbox"> 引用 flikr 的图片</li><li style="list-style: none"><input type="checkbox"> 相册样式的优化</li></ul><hr><hr><hr><p>  这是一个非常良好的开始… Hardworking … In the way… Never give up!</p><h2 id="——-END-——"><a href="#——-END-——" class="headerlink" title="—— END ——"></a>—— END ——</h2></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
    
    <summary type="html">
    
      &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css&quot;&gt;&lt;div class=&quot;.article-gallery&quot; &lt;blockquote=&quot;&quot;&gt;
&lt;h2 id=&quot;The-Happy-Beginning&quot;&gt;&lt;a href=&quot;#The-Happy-Beginning&quot; class=&quot;headerlink&quot; title=&quot;The Happy Beginning&quot;&gt;&lt;/a&gt;The Happy Beginning&lt;/h2&gt;
&lt;blockquote&gt;&lt;p&gt;工作能够稀释身心的毒素，使人得到升华…&lt;/p&gt;
&lt;footer&gt;&lt;strong&gt;[Inamori Kazuo]&lt;/strong&gt;&lt;/footer&gt;&lt;/blockquote&gt;
&lt;hr&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;2017 年 8 月 29 日&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　难得的早起，却是没能够充分利用这样的时间。&lt;/p&gt;
&lt;p&gt;　　清晨的空气是清新的，良好的作息带来规律的饮食，由此产生了身体和心灵上的愉悦。睡眠稍显不足，不过一杯龙井下肚便令人摆脱了睡意，开始博客的重搭建。&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://www.cpphonor.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="Diary" scheme="http://www.cpphonor.cn/categories/%E9%9A%8F%E7%AC%94/Diary/"/>
    
    
      <category term="Diary" scheme="http://www.cpphonor.cn/tags/Diary/"/>
    
      <category term="Footprint" scheme="http://www.cpphonor.cn/tags/Footprint/"/>
    
  </entry>
  
</feed>
